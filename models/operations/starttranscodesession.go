// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"github.com/LukeHagar/plexgo/internal/utils"
	"github.com/LukeHagar/plexgo/models/components"
	"io"
	"net/http"
)

type StartTranscodeSessionGlobals struct {
	// Indicates the client accepts the indicated media types
	Accepts *components.Accepts `default:"application/xml" header:"style=simple,explode=false,name=accepts"`
	// An opaque identifier unique to the client
	ClientIdentifier *string `header:"style=simple,explode=false,name=X-Plex-Client-Identifier"`
	// The name of the client product
	Product *string `header:"style=simple,explode=false,name=X-Plex-Product"`
	// The version of the client application
	Version *string `header:"style=simple,explode=false,name=X-Plex-Version"`
	// The platform of the client
	Platform *string `header:"style=simple,explode=false,name=X-Plex-Platform"`
	// The version of the platform
	PlatformVersion *string `header:"style=simple,explode=false,name=X-Plex-Platform-Version"`
	// A relatively friendly name for the client device
	Device *string `header:"style=simple,explode=false,name=X-Plex-Device"`
	// A potentially less friendly identifier for the device model
	Model *string `header:"style=simple,explode=false,name=X-Plex-Model"`
	// The device vendor
	DeviceVendor *string `header:"style=simple,explode=false,name=X-Plex-Device-Vendor"`
	// A friendly name for the client
	DeviceName *string `header:"style=simple,explode=false,name=X-Plex-Device-Name"`
	// The marketplace on which the client application is distributed
	Marketplace *string `header:"style=simple,explode=false,name=X-Plex-Marketplace"`
}

func (s StartTranscodeSessionGlobals) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *StartTranscodeSessionGlobals) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *StartTranscodeSessionGlobals) GetAccepts() *components.Accepts {
	if s == nil {
		return nil
	}
	return s.Accepts
}

func (s *StartTranscodeSessionGlobals) GetClientIdentifier() *string {
	if s == nil {
		return nil
	}
	return s.ClientIdentifier
}

func (s *StartTranscodeSessionGlobals) GetProduct() *string {
	if s == nil {
		return nil
	}
	return s.Product
}

func (s *StartTranscodeSessionGlobals) GetVersion() *string {
	if s == nil {
		return nil
	}
	return s.Version
}

func (s *StartTranscodeSessionGlobals) GetPlatform() *string {
	if s == nil {
		return nil
	}
	return s.Platform
}

func (s *StartTranscodeSessionGlobals) GetPlatformVersion() *string {
	if s == nil {
		return nil
	}
	return s.PlatformVersion
}

func (s *StartTranscodeSessionGlobals) GetDevice() *string {
	if s == nil {
		return nil
	}
	return s.Device
}

func (s *StartTranscodeSessionGlobals) GetModel() *string {
	if s == nil {
		return nil
	}
	return s.Model
}

func (s *StartTranscodeSessionGlobals) GetDeviceVendor() *string {
	if s == nil {
		return nil
	}
	return s.DeviceVendor
}

func (s *StartTranscodeSessionGlobals) GetDeviceName() *string {
	if s == nil {
		return nil
	}
	return s.DeviceName
}

func (s *StartTranscodeSessionGlobals) GetMarketplace() *string {
	if s == nil {
		return nil
	}
	return s.Marketplace
}

// Extension
type Extension string

const (
	ExtensionM3u8 Extension = "m3u8"
	ExtensionMpd  Extension = "mpd"
)

func (e Extension) ToPointer() *Extension {
	return &e
}
func (e *Extension) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "m3u8":
		fallthrough
	case "mpd":
		*e = Extension(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Extension: %v", v)
	}
}

// StartTranscodeSessionQueryParamLocation - Network type of the client, can be used to help determine target bitrate.
type StartTranscodeSessionQueryParamLocation string

const (
	StartTranscodeSessionQueryParamLocationLan      StartTranscodeSessionQueryParamLocation = "lan"
	StartTranscodeSessionQueryParamLocationWan      StartTranscodeSessionQueryParamLocation = "wan"
	StartTranscodeSessionQueryParamLocationCellular StartTranscodeSessionQueryParamLocation = "cellular"
)

func (e StartTranscodeSessionQueryParamLocation) ToPointer() *StartTranscodeSessionQueryParamLocation {
	return &e
}
func (e *StartTranscodeSessionQueryParamLocation) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "lan":
		fallthrough
	case "wan":
		fallthrough
	case "cellular":
		*e = StartTranscodeSessionQueryParamLocation(v)
		return nil
	default:
		return fmt.Errorf("invalid value for StartTranscodeSessionQueryParamLocation: %v", v)
	}
}

// StartTranscodeSessionQueryParamProtocol - Indicates the network streaming protocol to be used for the transcode session: * 'http' - include the file in the http response such as MKV streaming * 'hls' - hls stream (RFC 8216) * 'dash' - dash stream (ISO/IEC 23009-1:2022)
type StartTranscodeSessionQueryParamProtocol string

const (
	StartTranscodeSessionQueryParamProtocolHTTP StartTranscodeSessionQueryParamProtocol = "http"
	StartTranscodeSessionQueryParamProtocolHls  StartTranscodeSessionQueryParamProtocol = "hls"
	StartTranscodeSessionQueryParamProtocolDash StartTranscodeSessionQueryParamProtocol = "dash"
)

func (e StartTranscodeSessionQueryParamProtocol) ToPointer() *StartTranscodeSessionQueryParamProtocol {
	return &e
}
func (e *StartTranscodeSessionQueryParamProtocol) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "http":
		fallthrough
	case "hls":
		fallthrough
	case "dash":
		*e = StartTranscodeSessionQueryParamProtocol(v)
		return nil
	default:
		return fmt.Errorf("invalid value for StartTranscodeSessionQueryParamProtocol: %v", v)
	}
}

// StartTranscodeSessionQueryParamSubtitles - Indicates how subtitles should be included: * 'auto' - Compute the appropriate subtitle setting automatically * 'burn' - Burn the selected subtitle; auto if no selected subtitle * 'none' - Ignore all subtitle streams * 'sidecar' - The selected subtitle should be provided as a sidecar * 'embedded' - The selected subtitle should be provided as an embedded stream * 'segmented' - The selected subtitle should be provided as a segmented stream
type StartTranscodeSessionQueryParamSubtitles string

const (
	StartTranscodeSessionQueryParamSubtitlesAuto      StartTranscodeSessionQueryParamSubtitles = "auto"
	StartTranscodeSessionQueryParamSubtitlesBurn      StartTranscodeSessionQueryParamSubtitles = "burn"
	StartTranscodeSessionQueryParamSubtitlesNone      StartTranscodeSessionQueryParamSubtitles = "none"
	StartTranscodeSessionQueryParamSubtitlesSidecar   StartTranscodeSessionQueryParamSubtitles = "sidecar"
	StartTranscodeSessionQueryParamSubtitlesEmbedded  StartTranscodeSessionQueryParamSubtitles = "embedded"
	StartTranscodeSessionQueryParamSubtitlesSegmented StartTranscodeSessionQueryParamSubtitles = "segmented"
	StartTranscodeSessionQueryParamSubtitlesUnknown   StartTranscodeSessionQueryParamSubtitles = "unknown"
)

func (e StartTranscodeSessionQueryParamSubtitles) ToPointer() *StartTranscodeSessionQueryParamSubtitles {
	return &e
}
func (e *StartTranscodeSessionQueryParamSubtitles) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "auto":
		fallthrough
	case "burn":
		fallthrough
	case "none":
		fallthrough
	case "sidecar":
		fallthrough
	case "embedded":
		fallthrough
	case "segmented":
		fallthrough
	case "unknown":
		*e = StartTranscodeSessionQueryParamSubtitles(v)
		return nil
	default:
		return fmt.Errorf("invalid value for StartTranscodeSessionQueryParamSubtitles: %v", v)
	}
}

type StartTranscodeSessionRequest struct {
	// Indicates the client accepts the indicated media types
	Accepts *components.Accepts `default:"application/xml" header:"style=simple,explode=false,name=accepts"`
	// An opaque identifier unique to the client
	ClientIdentifier *string `header:"style=simple,explode=false,name=X-Plex-Client-Identifier"`
	// The name of the client product
	Product *string `header:"style=simple,explode=false,name=X-Plex-Product"`
	// The version of the client application
	Version *string `header:"style=simple,explode=false,name=X-Plex-Version"`
	// The platform of the client
	Platform *string `header:"style=simple,explode=false,name=X-Plex-Platform"`
	// The version of the platform
	PlatformVersion *string `header:"style=simple,explode=false,name=X-Plex-Platform-Version"`
	// A relatively friendly name for the client device
	Device *string `header:"style=simple,explode=false,name=X-Plex-Device"`
	// A potentially less friendly identifier for the device model
	Model *string `header:"style=simple,explode=false,name=X-Plex-Model"`
	// The device vendor
	DeviceVendor *string `header:"style=simple,explode=false,name=X-Plex-Device-Vendor"`
	// A friendly name for the client
	DeviceName *string `header:"style=simple,explode=false,name=X-Plex-Device-Name"`
	// The marketplace on which the client application is distributed
	Marketplace *string `header:"style=simple,explode=false,name=X-Plex-Marketplace"`
	// Type of transcode media
	TranscodeType components.TranscodeType `pathParam:"style=simple,explode=false,name=transcodeType"`
	// Transcode session UUID
	TranscodeSessionID *string `queryParam:"style=form,explode=true,name=transcodeSessionId"`
	// Extension
	//
	Extension Extension `pathParam:"style=simple,explode=false,name=extension"`
	// Indicates how incompatible advanced subtitles (such as ass/ssa) should be included: * 'burn' - Burn incompatible advanced text subtitles into the video stream * 'text' - Transcode incompatible advanced text subtitles to a compatible text format, even if some markup is lost
	//
	AdvancedSubtitles *components.AdvancedSubtitles `queryParam:"style=form,explode=true,name=advancedSubtitles"`
	// Percentage of original audio loudness to use when transcoding (100 is equivalent to original volume, 50 is half, 200 is double, etc)
	AudioBoost *int64 `queryParam:"style=form,explode=true,name=audioBoost"`
	// Target video number of audio channels.
	AudioChannelCount *int64 `queryParam:"style=form,explode=true,name=audioChannelCount"`
	// Indicates the client supports ABR.
	AutoAdjustQuality *components.BoolInt `queryParam:"style=form,explode=true,name=autoAdjustQuality"`
	// Indicates if the server should adjust subtitles based on Voice Activity Data.
	AutoAdjustSubtitle *components.BoolInt `queryParam:"style=form,explode=true,name=autoAdjustSubtitle"`
	// Indicates the client supports direct playing the indicated content.
	DirectPlay *components.BoolInt `queryParam:"style=form,explode=true,name=directPlay"`
	// Indicates the client supports direct streaming the video of the indicated content.
	DirectStream *components.BoolInt `queryParam:"style=form,explode=true,name=directStream"`
	// Indicates the client supports direct streaming the audio of the indicated content.
	DirectStreamAudio *components.BoolInt `queryParam:"style=form,explode=true,name=directStreamAudio"`
	// Indicates if resolution should be adjusted for orientation.
	DisableResolutionRotation *components.BoolInt `queryParam:"style=form,explode=true,name=disableResolutionRotation"`
	// Ignore client profiles when determining if direct play is possible. Only has an effect when directPlay=1 and both mediaIndex and partIndex are specified and neither are -1
	HasMDE *components.BoolInt `queryParam:"style=form,explode=true,name=hasMDE"`
	// Network type of the client, can be used to help determine target bitrate.
	Location *StartTranscodeSessionQueryParamLocation `queryParam:"style=form,explode=true,name=location"`
	// Buffer size used in playback (in KB). Clients should specify a lower bound if not known exactly. This value could make the difference between transcoding and direct play on bandwidth constrained networks.
	MediaBufferSize *int64 `queryParam:"style=form,explode=true,name=mediaBufferSize"`
	// Index of the media to transcode. -1 or not specified indicates let the server choose.
	MediaIndex *int64 `queryParam:"style=form,explode=true,name=mediaIndex"`
	// Target bitrate for audio only files (in kbps, used to transcode).
	MusicBitrate *int64 `queryParam:"style=form,explode=true,name=musicBitrate"`
	// Offset from the start of the media (in seconds).
	Offset *float64 `queryParam:"style=form,explode=true,name=offset"`
	// Index of the part to transcode. -1 or not specified indicates the server should join parts together in a transcode
	PartIndex *int64 `queryParam:"style=form,explode=true,name=partIndex"`
	// Internal PMS path of the media to transcode.
	Path *string `queryParam:"style=form,explode=true,name=path"`
	// Maximum bitrate (in kbps) to use in ABR.
	PeakBitrate *int64 `queryParam:"style=form,explode=true,name=peakBitrate"`
	// Target photo resolution.
	PhotoResolution *string `queryParam:"style=form,explode=true,name=photoResolution"`
	// Indicates the network streaming protocol to be used for the transcode session: * 'http' - include the file in the http response such as MKV streaming * 'hls' - hls stream (RFC 8216) * 'dash' - dash stream (ISO/IEC 23009-1:2022)
	//
	Protocol *StartTranscodeSessionQueryParamProtocol `queryParam:"style=form,explode=true,name=protocol"`
	// Number of seconds to include in each transcoded segment
	SecondsPerSegment *int64 `queryParam:"style=form,explode=true,name=secondsPerSegment"`
	// Percentage of original subtitle size to use when burning subtitles (100 is equivalent to original size, 50 is half, ect)
	SubtitleSize *int64 `queryParam:"style=form,explode=true,name=subtitleSize"`
	// Indicates how subtitles should be included: * 'auto' - Compute the appropriate subtitle setting automatically * 'burn' - Burn the selected subtitle; auto if no selected subtitle * 'none' - Ignore all subtitle streams * 'sidecar' - The selected subtitle should be provided as a sidecar * 'embedded' - The selected subtitle should be provided as an embedded stream * 'segmented' - The selected subtitle should be provided as a segmented stream
	//
	Subtitles *StartTranscodeSessionQueryParamSubtitles `queryParam:"style=form,explode=true,name=subtitles"`
	// Target video bitrate (in kbps).
	VideoBitrate *int64 `queryParam:"style=form,explode=true,name=videoBitrate"`
	// Target photo quality.
	VideoQuality *int64 `queryParam:"style=form,explode=true,name=videoQuality"`
	// Target maximum video resolution.
	VideoResolution *string `queryParam:"style=form,explode=true,name=videoResolution"`
	// See [Profile Augmentations](#section/API-Info/Profile-Augmentations) .
	XPlexClientProfileExtra *string `header:"style=simple,explode=false,name=X-Plex-Client-Profile-Extra"`
	// Which built in Client Profile to use in the decision. Generally should only be used to specify the Generic profile.
	XPlexClientProfileName *string `header:"style=simple,explode=false,name=X-Plex-Client-Profile-Name"`
	// Unique per client playback session.  Used if a client can playback multiple items at a time (such as a browser with multiple tabs)
	XPlexSessionIdentifier *string `header:"style=simple,explode=false,name=X-Plex-Session-Identifier"`
}

func (s StartTranscodeSessionRequest) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *StartTranscodeSessionRequest) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"transcodeType", "extension"}); err != nil {
		return err
	}
	return nil
}

func (s *StartTranscodeSessionRequest) GetAccepts() *components.Accepts {
	if s == nil {
		return nil
	}
	return s.Accepts
}

func (s *StartTranscodeSessionRequest) GetClientIdentifier() *string {
	if s == nil {
		return nil
	}
	return s.ClientIdentifier
}

func (s *StartTranscodeSessionRequest) GetProduct() *string {
	if s == nil {
		return nil
	}
	return s.Product
}

func (s *StartTranscodeSessionRequest) GetVersion() *string {
	if s == nil {
		return nil
	}
	return s.Version
}

func (s *StartTranscodeSessionRequest) GetPlatform() *string {
	if s == nil {
		return nil
	}
	return s.Platform
}

func (s *StartTranscodeSessionRequest) GetPlatformVersion() *string {
	if s == nil {
		return nil
	}
	return s.PlatformVersion
}

func (s *StartTranscodeSessionRequest) GetDevice() *string {
	if s == nil {
		return nil
	}
	return s.Device
}

func (s *StartTranscodeSessionRequest) GetModel() *string {
	if s == nil {
		return nil
	}
	return s.Model
}

func (s *StartTranscodeSessionRequest) GetDeviceVendor() *string {
	if s == nil {
		return nil
	}
	return s.DeviceVendor
}

func (s *StartTranscodeSessionRequest) GetDeviceName() *string {
	if s == nil {
		return nil
	}
	return s.DeviceName
}

func (s *StartTranscodeSessionRequest) GetMarketplace() *string {
	if s == nil {
		return nil
	}
	return s.Marketplace
}

func (s *StartTranscodeSessionRequest) GetTranscodeType() components.TranscodeType {
	if s == nil {
		return components.TranscodeType("")
	}
	return s.TranscodeType
}

func (s *StartTranscodeSessionRequest) GetTranscodeSessionID() *string {
	if s == nil {
		return nil
	}
	return s.TranscodeSessionID
}

func (s *StartTranscodeSessionRequest) GetExtension() Extension {
	if s == nil {
		return Extension("")
	}
	return s.Extension
}

func (s *StartTranscodeSessionRequest) GetAdvancedSubtitles() *components.AdvancedSubtitles {
	if s == nil {
		return nil
	}
	return s.AdvancedSubtitles
}

func (s *StartTranscodeSessionRequest) GetAudioBoost() *int64 {
	if s == nil {
		return nil
	}
	return s.AudioBoost
}

func (s *StartTranscodeSessionRequest) GetAudioChannelCount() *int64 {
	if s == nil {
		return nil
	}
	return s.AudioChannelCount
}

func (s *StartTranscodeSessionRequest) GetAutoAdjustQuality() *components.BoolInt {
	if s == nil {
		return nil
	}
	return s.AutoAdjustQuality
}

func (s *StartTranscodeSessionRequest) GetAutoAdjustSubtitle() *components.BoolInt {
	if s == nil {
		return nil
	}
	return s.AutoAdjustSubtitle
}

func (s *StartTranscodeSessionRequest) GetDirectPlay() *components.BoolInt {
	if s == nil {
		return nil
	}
	return s.DirectPlay
}

func (s *StartTranscodeSessionRequest) GetDirectStream() *components.BoolInt {
	if s == nil {
		return nil
	}
	return s.DirectStream
}

func (s *StartTranscodeSessionRequest) GetDirectStreamAudio() *components.BoolInt {
	if s == nil {
		return nil
	}
	return s.DirectStreamAudio
}

func (s *StartTranscodeSessionRequest) GetDisableResolutionRotation() *components.BoolInt {
	if s == nil {
		return nil
	}
	return s.DisableResolutionRotation
}

func (s *StartTranscodeSessionRequest) GetHasMDE() *components.BoolInt {
	if s == nil {
		return nil
	}
	return s.HasMDE
}

func (s *StartTranscodeSessionRequest) GetLocation() *StartTranscodeSessionQueryParamLocation {
	if s == nil {
		return nil
	}
	return s.Location
}

func (s *StartTranscodeSessionRequest) GetMediaBufferSize() *int64 {
	if s == nil {
		return nil
	}
	return s.MediaBufferSize
}

func (s *StartTranscodeSessionRequest) GetMediaIndex() *int64 {
	if s == nil {
		return nil
	}
	return s.MediaIndex
}

func (s *StartTranscodeSessionRequest) GetMusicBitrate() *int64 {
	if s == nil {
		return nil
	}
	return s.MusicBitrate
}

func (s *StartTranscodeSessionRequest) GetOffset() *float64 {
	if s == nil {
		return nil
	}
	return s.Offset
}

func (s *StartTranscodeSessionRequest) GetPartIndex() *int64 {
	if s == nil {
		return nil
	}
	return s.PartIndex
}

func (s *StartTranscodeSessionRequest) GetPath() *string {
	if s == nil {
		return nil
	}
	return s.Path
}

func (s *StartTranscodeSessionRequest) GetPeakBitrate() *int64 {
	if s == nil {
		return nil
	}
	return s.PeakBitrate
}

func (s *StartTranscodeSessionRequest) GetPhotoResolution() *string {
	if s == nil {
		return nil
	}
	return s.PhotoResolution
}

func (s *StartTranscodeSessionRequest) GetProtocol() *StartTranscodeSessionQueryParamProtocol {
	if s == nil {
		return nil
	}
	return s.Protocol
}

func (s *StartTranscodeSessionRequest) GetSecondsPerSegment() *int64 {
	if s == nil {
		return nil
	}
	return s.SecondsPerSegment
}

func (s *StartTranscodeSessionRequest) GetSubtitleSize() *int64 {
	if s == nil {
		return nil
	}
	return s.SubtitleSize
}

func (s *StartTranscodeSessionRequest) GetSubtitles() *StartTranscodeSessionQueryParamSubtitles {
	if s == nil {
		return nil
	}
	return s.Subtitles
}

func (s *StartTranscodeSessionRequest) GetVideoBitrate() *int64 {
	if s == nil {
		return nil
	}
	return s.VideoBitrate
}

func (s *StartTranscodeSessionRequest) GetVideoQuality() *int64 {
	if s == nil {
		return nil
	}
	return s.VideoQuality
}

func (s *StartTranscodeSessionRequest) GetVideoResolution() *string {
	if s == nil {
		return nil
	}
	return s.VideoResolution
}

func (s *StartTranscodeSessionRequest) GetXPlexClientProfileExtra() *string {
	if s == nil {
		return nil
	}
	return s.XPlexClientProfileExtra
}

func (s *StartTranscodeSessionRequest) GetXPlexClientProfileName() *string {
	if s == nil {
		return nil
	}
	return s.XPlexClientProfileName
}

func (s *StartTranscodeSessionRequest) GetXPlexSessionIdentifier() *string {
	if s == nil {
		return nil
	}
	return s.XPlexSessionIdentifier
}

type StartTranscodeSessionResponse struct {
	// HTTP response content type for this operation
	ContentType string
	// HTTP response status code for this operation
	StatusCode int
	// Raw HTTP response; suitable for custom response parsing
	RawResponse *http.Response
	// MPD file (see ISO/IEC 23009-1:2022), m3u8 file (see RFC 8216), or binary http stream
	// The Close method must be called on this field, even if it is not used, to prevent resource leaks.
	ResponseStream io.ReadCloser
}

func (s *StartTranscodeSessionResponse) GetContentType() string {
	if s == nil {
		return ""
	}
	return s.ContentType
}

func (s *StartTranscodeSessionResponse) GetStatusCode() int {
	if s == nil {
		return 0
	}
	return s.StatusCode
}

func (s *StartTranscodeSessionResponse) GetRawResponse() *http.Response {
	if s == nil {
		return nil
	}
	return s.RawResponse
}

func (s *StartTranscodeSessionResponse) GetResponseStream() io.ReadCloser {
	if s == nil {
		return nil
	}
	return s.ResponseStream
}
