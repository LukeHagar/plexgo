// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"github.com/LukeHagar/plexgo/internal/utils"
	"net/http"
)

var GetTokenDetailsServerList = []string{
	"https://plex.tv/api/v2",
}

// MailingListStatus - Your current mailing list status (active or unsubscribed)
type MailingListStatus string

const (
	MailingListStatusActive       MailingListStatus = "active"
	MailingListStatusUnsubscribed MailingListStatus = "unsubscribed"
)

func (e MailingListStatus) ToPointer() *MailingListStatus {
	return &e
}

// AutoSelectSubtitle - The auto-select subtitle mode (0 = Manually selected, 1 = Shown with foreign audio, 2 = Always enabled)
type AutoSelectSubtitle int

const (
	AutoSelectSubtitleDisable AutoSelectSubtitle = 0
	AutoSelectSubtitleEnable  AutoSelectSubtitle = 1
)

func (e AutoSelectSubtitle) ToPointer() *AutoSelectSubtitle {
	return &e
}
func (e *AutoSelectSubtitle) UnmarshalJSON(data []byte) error {
	var v int
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 0:
		fallthrough
	case 1:
		*e = AutoSelectSubtitle(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AutoSelectSubtitle: %v", v)
	}
}

// DefaultSubtitleAccessibility - The subtitles for the deaf or hard-of-hearing (SDH) searches mode (0 = Prefer non-SDH subtitles, 1 = Prefer SDH subtitles, 2 = Only show SDH subtitles, 3 = Only show non-SDH subtitles)
type DefaultSubtitleAccessibility int

const (
	DefaultSubtitleAccessibilityDisable DefaultSubtitleAccessibility = 0
	DefaultSubtitleAccessibilityEnable  DefaultSubtitleAccessibility = 1
)

func (e DefaultSubtitleAccessibility) ToPointer() *DefaultSubtitleAccessibility {
	return &e
}
func (e *DefaultSubtitleAccessibility) UnmarshalJSON(data []byte) error {
	var v int
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 0:
		fallthrough
	case 1:
		*e = DefaultSubtitleAccessibility(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DefaultSubtitleAccessibility: %v", v)
	}
}

// DefaultSubtitleForced - The forced subtitles searches mode (0 = Prefer non-forced subtitles, 1 = Prefer forced subtitles, 2 = Only show forced subtitles, 3 = Only show non-forced subtitles)
type DefaultSubtitleForced int

const (
	DefaultSubtitleForcedDisable DefaultSubtitleForced = 0
	DefaultSubtitleForcedEnable  DefaultSubtitleForced = 1
)

func (e DefaultSubtitleForced) ToPointer() *DefaultSubtitleForced {
	return &e
}
func (e *DefaultSubtitleForced) UnmarshalJSON(data []byte) error {
	var v int
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 0:
		fallthrough
	case 1:
		*e = DefaultSubtitleForced(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DefaultSubtitleForced: %v", v)
	}
}

// WatchedIndicator - Whether or not media watched indicators are enabled (little orange dot on media)
type WatchedIndicator int

const (
	WatchedIndicatorDisable WatchedIndicator = 0
	WatchedIndicatorEnable  WatchedIndicator = 1
)

func (e WatchedIndicator) ToPointer() *WatchedIndicator {
	return &e
}
func (e *WatchedIndicator) UnmarshalJSON(data []byte) error {
	var v int
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 0:
		fallthrough
	case 1:
		*e = WatchedIndicator(v)
		return nil
	default:
		return fmt.Errorf("invalid value for WatchedIndicator: %v", v)
	}
}

// MediaReviewsVisibility - Whether or not the account has media reviews visibility enabled
type MediaReviewsVisibility int

const (
	MediaReviewsVisibilityDisable MediaReviewsVisibility = 0
	MediaReviewsVisibilityEnable  MediaReviewsVisibility = 1
)

func (e MediaReviewsVisibility) ToPointer() *MediaReviewsVisibility {
	return &e
}
func (e *MediaReviewsVisibility) UnmarshalJSON(data []byte) error {
	var v int
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 0:
		fallthrough
	case 1:
		*e = MediaReviewsVisibility(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MediaReviewsVisibility: %v", v)
	}
}

type UserProfile struct {
	// If the account has automatically select audio and subtitle tracks enabled
	AutoSelectAudio *bool `default:"true" json:"autoSelectAudio"`
	// The preferred audio language for the account
	DefaultAudioLanguage *string `json:"defaultAudioLanguage"`
	// The preferred subtitle language for the account
	DefaultSubtitleLanguage      *string                       `json:"defaultSubtitleLanguage"`
	AutoSelectSubtitle           *AutoSelectSubtitle           `default:"0" json:"autoSelectSubtitle"`
	DefaultSubtitleAccessibility *DefaultSubtitleAccessibility `default:"0" json:"defaultSubtitleAccessibility"`
	DefaultSubtitleForced        *DefaultSubtitleForced        `default:"0" json:"defaultSubtitleForced"`
	WatchedIndicator             *WatchedIndicator             `default:"0" json:"watchedIndicator"`
	MediaReviewsVisibility       *MediaReviewsVisibility       `default:"0" json:"mediaReviewsVisibility"`
}

func (u UserProfile) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(u, "", false)
}

func (u *UserProfile) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &u, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (u *UserProfile) GetAutoSelectAudio() *bool {
	if u == nil {
		return nil
	}
	return u.AutoSelectAudio
}

func (u *UserProfile) GetDefaultAudioLanguage() *string {
	if u == nil {
		return nil
	}
	return u.DefaultAudioLanguage
}

func (u *UserProfile) GetDefaultSubtitleLanguage() *string {
	if u == nil {
		return nil
	}
	return u.DefaultSubtitleLanguage
}

func (u *UserProfile) GetAutoSelectSubtitle() *AutoSelectSubtitle {
	if u == nil {
		return nil
	}
	return u.AutoSelectSubtitle
}

func (u *UserProfile) GetDefaultSubtitleAccessibility() *DefaultSubtitleAccessibility {
	if u == nil {
		return nil
	}
	return u.DefaultSubtitleAccessibility
}

func (u *UserProfile) GetDefaultSubtitleForced() *DefaultSubtitleForced {
	if u == nil {
		return nil
	}
	return u.DefaultSubtitleForced
}

func (u *UserProfile) GetWatchedIndicator() *WatchedIndicator {
	if u == nil {
		return nil
	}
	return u.WatchedIndicator
}

func (u *UserProfile) GetMediaReviewsVisibility() *MediaReviewsVisibility {
	if u == nil {
		return nil
	}
	return u.MediaReviewsVisibility
}

type GetTokenDetailsStatus string

const (
	GetTokenDetailsStatusOnline  GetTokenDetailsStatus = "online"
	GetTokenDetailsStatusOffline GetTokenDetailsStatus = "offline"
)

func (e GetTokenDetailsStatus) ToPointer() *GetTokenDetailsStatus {
	return &e
}

type Services struct {
	Identifier string                `json:"identifier"`
	Endpoint   string                `json:"endpoint"`
	Token      *string               `json:"token"`
	Secret     *string               `json:"secret"`
	Status     GetTokenDetailsStatus `json:"status"`
}

func (s *Services) GetIdentifier() string {
	if s == nil {
		return ""
	}
	return s.Identifier
}

func (s *Services) GetEndpoint() string {
	if s == nil {
		return ""
	}
	return s.Endpoint
}

func (s *Services) GetToken() *string {
	if s == nil {
		return nil
	}
	return s.Token
}

func (s *Services) GetSecret() *string {
	if s == nil {
		return nil
	}
	return s.Secret
}

func (s *Services) GetStatus() GetTokenDetailsStatus {
	if s == nil {
		return GetTokenDetailsStatus("")
	}
	return s.Status
}

// GetTokenDetailsAuthenticationStatus - String representation of subscriptionActive
type GetTokenDetailsAuthenticationStatus string

const (
	GetTokenDetailsAuthenticationStatusInactive GetTokenDetailsAuthenticationStatus = "Inactive"
	GetTokenDetailsAuthenticationStatusActive   GetTokenDetailsAuthenticationStatus = "Active"
)

func (e GetTokenDetailsAuthenticationStatus) ToPointer() *GetTokenDetailsAuthenticationStatus {
	return &e
}

// Subscription - If the accountâ€™s Plex Pass subscription is active
type Subscription struct {
	// List of features allowed on your Plex Pass subscription
	Features []string `json:"features,omitempty"`
	// If the account's Plex Pass subscription is active
	Active *bool `json:"active,omitempty"`
	// Date the account subscribed to Plex Pass
	SubscribedAt *string `json:"subscribedAt,omitempty"`
	// String representation of subscriptionActive
	Status *GetTokenDetailsAuthenticationStatus `json:"status,omitempty"`
	// Payment service used for your Plex Pass subscription
	PaymentService *string `json:"paymentService,omitempty"`
	// Name of Plex Pass subscription plan
	Plan *string `json:"plan,omitempty"`
}

func (s *Subscription) GetFeatures() []string {
	if s == nil {
		return nil
	}
	return s.Features
}

func (s *Subscription) GetActive() *bool {
	if s == nil {
		return nil
	}
	return s.Active
}

func (s *Subscription) GetSubscribedAt() *string {
	if s == nil {
		return nil
	}
	return s.SubscribedAt
}

func (s *Subscription) GetStatus() *GetTokenDetailsAuthenticationStatus {
	if s == nil {
		return nil
	}
	return s.Status
}

func (s *Subscription) GetPaymentService() *string {
	if s == nil {
		return nil
	}
	return s.PaymentService
}

func (s *Subscription) GetPlan() *string {
	if s == nil {
		return nil
	}
	return s.Plan
}

// GetTokenDetailsAuthenticationResponseStatus - String representation of subscriptionActive
type GetTokenDetailsAuthenticationResponseStatus string

const (
	GetTokenDetailsAuthenticationResponseStatusInactive GetTokenDetailsAuthenticationResponseStatus = "Inactive"
	GetTokenDetailsAuthenticationResponseStatusActive   GetTokenDetailsAuthenticationResponseStatus = "Active"
)

func (e GetTokenDetailsAuthenticationResponseStatus) ToPointer() *GetTokenDetailsAuthenticationResponseStatus {
	return &e
}

type GetTokenDetailsSubscription struct {
	// List of features allowed on your Plex Pass subscription
	Features []string `json:"features,omitempty"`
	// If the account's Plex Pass subscription is active
	Active *bool `json:"active,omitempty"`
	// Date the account subscribed to Plex Pass
	SubscribedAt *string `json:"subscribedAt,omitempty"`
	// String representation of subscriptionActive
	Status *GetTokenDetailsAuthenticationResponseStatus `json:"status,omitempty"`
	// Payment service used for your Plex Pass subscription
	PaymentService *string `json:"paymentService,omitempty"`
	// Name of Plex Pass subscription plan
	Plan *string `json:"plan,omitempty"`
}

func (g *GetTokenDetailsSubscription) GetFeatures() []string {
	if g == nil {
		return nil
	}
	return g.Features
}

func (g *GetTokenDetailsSubscription) GetActive() *bool {
	if g == nil {
		return nil
	}
	return g.Active
}

func (g *GetTokenDetailsSubscription) GetSubscribedAt() *string {
	if g == nil {
		return nil
	}
	return g.SubscribedAt
}

func (g *GetTokenDetailsSubscription) GetStatus() *GetTokenDetailsAuthenticationResponseStatus {
	if g == nil {
		return nil
	}
	return g.Status
}

func (g *GetTokenDetailsSubscription) GetPaymentService() *string {
	if g == nil {
		return nil
	}
	return g.PaymentService
}

func (g *GetTokenDetailsSubscription) GetPlan() *string {
	if g == nil {
		return nil
	}
	return g.Plan
}

// GetTokenDetailsUserPlexAccount - Logged in user details
type GetTokenDetailsUserPlexAccount struct {
	// Unknown
	AdsConsent           *bool  `json:"adsConsent"`
	AdsConsentReminderAt *int64 `json:"adsConsentReminderAt"`
	AdsConsentSetAt      *int64 `json:"adsConsentSetAt"`
	// Unknown
	Anonymous *bool `default:"false" json:"anonymous"`
	// The account token
	AuthToken string `json:"authToken"`
	// If the two-factor authentication backup codes have been created
	BackupCodesCreated *bool `default:"false" json:"backupCodesCreated"`
	// If the account has been confirmed
	Confirmed *bool `default:"false" json:"confirmed"`
	// The account country
	Country string `json:"country"`
	// The account email address
	Email string `json:"email"`
	// If login with email only is enabled
	EmailOnlyAuth *bool `default:"false" json:"emailOnlyAuth"`
	// If experimental features are enabled
	ExperimentalFeatures *bool `default:"false" json:"experimentalFeatures"`
	// Your account full name
	FriendlyName string `json:"friendlyName"`
	// List of devices your allowed to use with this account
	Entitlements []string `json:"entitlements"`
	// If the account is a Plex Home guest user
	Guest *bool `default:"false" json:"guest"`
	// If the account has a password
	HasPassword *bool `default:"true" json:"hasPassword"`
	// If the account is a Plex Home user
	Home *bool `default:"false" json:"home"`
	// If the account is the Plex Home admin
	HomeAdmin *bool `default:"false" json:"homeAdmin"`
	// The number of accounts in the Plex Home
	HomeSize int `json:"homeSize"`
	// The Plex account ID
	ID int `json:"id"`
	// Unix epoch datetime in seconds
	JoinedAt int64 `json:"joinedAt"`
	// The account locale
	Locale *string `json:"locale"`
	// If you are subscribed to the Plex newsletter
	MailingListActive *bool `default:"false" json:"mailingListActive"`
	// Your current mailing list status (active or unsubscribed)
	MailingListStatus MailingListStatus `json:"mailingListStatus"`
	// The maximum number of accounts allowed in the Plex Home
	MaxHomeSize int `json:"maxHomeSize"`
	// [Might be removed] The hashed Plex Home PIN
	//
	// Deprecated: This will be removed in a future release, please migrate away from it as soon as possible.
	Pin     *string     `json:"pin,omitempty"`
	Profile UserProfile `json:"profile"`
	// If the account has a Plex Home PIN enabled
	Protected *bool `default:"false" json:"protected"`
	// Unix epoch datetime in seconds
	RememberExpiresAt int64 `json:"rememberExpiresAt"`
	// If the account is a Plex Home managed user
	Restricted *bool `default:"false" json:"restricted"`
	// [Might be removed] List of account roles. Plexpass membership listed here
	Roles []string `json:"roles,omitempty"`
	// Unknown
	ScrobbleTypes string     `json:"scrobbleTypes"`
	Services      []Services `json:"services"`
	// If the accountâ€™s Plex Pass subscription is active
	Subscription Subscription `json:"subscription"`
	// Description of the Plex Pass subscription
	SubscriptionDescription *string                       `json:"subscriptionDescription"`
	Subscriptions           []GetTokenDetailsSubscription `json:"subscriptions,omitempty"`
	// URL of the account thumbnail
	Thumb string `json:"thumb"`
	// The title of the account (username or friendly name)
	Title string `json:"title"`
	// If two-factor authentication is enabled
	TwoFactorEnabled *bool `default:"false" json:"twoFactorEnabled"`
	// The account username
	Username string `json:"username"`
	// The account UUID
	UUID               string  `json:"uuid"`
	AttributionPartner *string `json:"attributionPartner"`
}

func (g GetTokenDetailsUserPlexAccount) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetTokenDetailsUserPlexAccount) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"authToken", "country", "email", "friendlyName", "entitlements", "homeSize", "id", "joinedAt", "mailingListStatus", "maxHomeSize", "profile", "rememberExpiresAt", "scrobbleTypes", "services", "subscription", "thumb", "title", "username", "uuid"}); err != nil {
		return err
	}
	return nil
}

func (g *GetTokenDetailsUserPlexAccount) GetAdsConsent() *bool {
	if g == nil {
		return nil
	}
	return g.AdsConsent
}

func (g *GetTokenDetailsUserPlexAccount) GetAdsConsentReminderAt() *int64 {
	if g == nil {
		return nil
	}
	return g.AdsConsentReminderAt
}

func (g *GetTokenDetailsUserPlexAccount) GetAdsConsentSetAt() *int64 {
	if g == nil {
		return nil
	}
	return g.AdsConsentSetAt
}

func (g *GetTokenDetailsUserPlexAccount) GetAnonymous() *bool {
	if g == nil {
		return nil
	}
	return g.Anonymous
}

func (g *GetTokenDetailsUserPlexAccount) GetAuthToken() string {
	if g == nil {
		return ""
	}
	return g.AuthToken
}

func (g *GetTokenDetailsUserPlexAccount) GetBackupCodesCreated() *bool {
	if g == nil {
		return nil
	}
	return g.BackupCodesCreated
}

func (g *GetTokenDetailsUserPlexAccount) GetConfirmed() *bool {
	if g == nil {
		return nil
	}
	return g.Confirmed
}

func (g *GetTokenDetailsUserPlexAccount) GetCountry() string {
	if g == nil {
		return ""
	}
	return g.Country
}

func (g *GetTokenDetailsUserPlexAccount) GetEmail() string {
	if g == nil {
		return ""
	}
	return g.Email
}

func (g *GetTokenDetailsUserPlexAccount) GetEmailOnlyAuth() *bool {
	if g == nil {
		return nil
	}
	return g.EmailOnlyAuth
}

func (g *GetTokenDetailsUserPlexAccount) GetExperimentalFeatures() *bool {
	if g == nil {
		return nil
	}
	return g.ExperimentalFeatures
}

func (g *GetTokenDetailsUserPlexAccount) GetFriendlyName() string {
	if g == nil {
		return ""
	}
	return g.FriendlyName
}

func (g *GetTokenDetailsUserPlexAccount) GetEntitlements() []string {
	if g == nil {
		return []string{}
	}
	return g.Entitlements
}

func (g *GetTokenDetailsUserPlexAccount) GetGuest() *bool {
	if g == nil {
		return nil
	}
	return g.Guest
}

func (g *GetTokenDetailsUserPlexAccount) GetHasPassword() *bool {
	if g == nil {
		return nil
	}
	return g.HasPassword
}

func (g *GetTokenDetailsUserPlexAccount) GetHome() *bool {
	if g == nil {
		return nil
	}
	return g.Home
}

func (g *GetTokenDetailsUserPlexAccount) GetHomeAdmin() *bool {
	if g == nil {
		return nil
	}
	return g.HomeAdmin
}

func (g *GetTokenDetailsUserPlexAccount) GetHomeSize() int {
	if g == nil {
		return 0
	}
	return g.HomeSize
}

func (g *GetTokenDetailsUserPlexAccount) GetID() int {
	if g == nil {
		return 0
	}
	return g.ID
}

func (g *GetTokenDetailsUserPlexAccount) GetJoinedAt() int64 {
	if g == nil {
		return 0
	}
	return g.JoinedAt
}

func (g *GetTokenDetailsUserPlexAccount) GetLocale() *string {
	if g == nil {
		return nil
	}
	return g.Locale
}

func (g *GetTokenDetailsUserPlexAccount) GetMailingListActive() *bool {
	if g == nil {
		return nil
	}
	return g.MailingListActive
}

func (g *GetTokenDetailsUserPlexAccount) GetMailingListStatus() MailingListStatus {
	if g == nil {
		return MailingListStatus("")
	}
	return g.MailingListStatus
}

func (g *GetTokenDetailsUserPlexAccount) GetMaxHomeSize() int {
	if g == nil {
		return 0
	}
	return g.MaxHomeSize
}

func (g *GetTokenDetailsUserPlexAccount) GetPin() *string {
	if g == nil {
		return nil
	}
	return g.Pin
}

func (g *GetTokenDetailsUserPlexAccount) GetProfile() UserProfile {
	if g == nil {
		return UserProfile{}
	}
	return g.Profile
}

func (g *GetTokenDetailsUserPlexAccount) GetProtected() *bool {
	if g == nil {
		return nil
	}
	return g.Protected
}

func (g *GetTokenDetailsUserPlexAccount) GetRememberExpiresAt() int64 {
	if g == nil {
		return 0
	}
	return g.RememberExpiresAt
}

func (g *GetTokenDetailsUserPlexAccount) GetRestricted() *bool {
	if g == nil {
		return nil
	}
	return g.Restricted
}

func (g *GetTokenDetailsUserPlexAccount) GetRoles() []string {
	if g == nil {
		return nil
	}
	return g.Roles
}

func (g *GetTokenDetailsUserPlexAccount) GetScrobbleTypes() string {
	if g == nil {
		return ""
	}
	return g.ScrobbleTypes
}

func (g *GetTokenDetailsUserPlexAccount) GetServices() []Services {
	if g == nil {
		return []Services{}
	}
	return g.Services
}

func (g *GetTokenDetailsUserPlexAccount) GetSubscription() Subscription {
	if g == nil {
		return Subscription{}
	}
	return g.Subscription
}

func (g *GetTokenDetailsUserPlexAccount) GetSubscriptionDescription() *string {
	if g == nil {
		return nil
	}
	return g.SubscriptionDescription
}

func (g *GetTokenDetailsUserPlexAccount) GetSubscriptions() []GetTokenDetailsSubscription {
	if g == nil {
		return nil
	}
	return g.Subscriptions
}

func (g *GetTokenDetailsUserPlexAccount) GetThumb() string {
	if g == nil {
		return ""
	}
	return g.Thumb
}

func (g *GetTokenDetailsUserPlexAccount) GetTitle() string {
	if g == nil {
		return ""
	}
	return g.Title
}

func (g *GetTokenDetailsUserPlexAccount) GetTwoFactorEnabled() *bool {
	if g == nil {
		return nil
	}
	return g.TwoFactorEnabled
}

func (g *GetTokenDetailsUserPlexAccount) GetUsername() string {
	if g == nil {
		return ""
	}
	return g.Username
}

func (g *GetTokenDetailsUserPlexAccount) GetUUID() string {
	if g == nil {
		return ""
	}
	return g.UUID
}

func (g *GetTokenDetailsUserPlexAccount) GetAttributionPartner() *string {
	if g == nil {
		return nil
	}
	return g.AttributionPartner
}

type GetTokenDetailsResponse struct {
	// HTTP response content type for this operation
	ContentType string
	// HTTP response status code for this operation
	StatusCode int
	// Raw HTTP response; suitable for custom response parsing
	RawResponse *http.Response
	// Logged in user details
	UserPlexAccount *GetTokenDetailsUserPlexAccount
}

func (g *GetTokenDetailsResponse) GetContentType() string {
	if g == nil {
		return ""
	}
	return g.ContentType
}

func (g *GetTokenDetailsResponse) GetStatusCode() int {
	if g == nil {
		return 0
	}
	return g.StatusCode
}

func (g *GetTokenDetailsResponse) GetRawResponse() *http.Response {
	if g == nil {
		return nil
	}
	return g.RawResponse
}

func (g *GetTokenDetailsResponse) GetUserPlexAccount() *GetTokenDetailsUserPlexAccount {
	if g == nil {
		return nil
	}
	return g.UserPlexAccount
}
