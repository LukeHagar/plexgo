// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"github.com/LukeHagar/plexgo/internal/utils"
	"github.com/LukeHagar/plexgo/models/components"
	"net/http"
)

type ReportGlobals struct {
	// Indicates the client accepts the indicated media types
	Accepts *components.Accepts `default:"application/xml" header:"style=simple,explode=false,name=accepts"`
	// An opaque identifier unique to the client
	ClientIdentifier *string `header:"style=simple,explode=false,name=X-Plex-Client-Identifier"`
	// The name of the client product
	Product *string `header:"style=simple,explode=false,name=X-Plex-Product"`
	// The version of the client application
	Version *string `header:"style=simple,explode=false,name=X-Plex-Version"`
	// The platform of the client
	Platform *string `header:"style=simple,explode=false,name=X-Plex-Platform"`
	// The version of the platform
	PlatformVersion *string `header:"style=simple,explode=false,name=X-Plex-Platform-Version"`
	// A relatively friendly name for the client device
	Device *string `header:"style=simple,explode=false,name=X-Plex-Device"`
	// A potentially less friendly identifier for the device model
	Model *string `header:"style=simple,explode=false,name=X-Plex-Model"`
	// The device vendor
	DeviceVendor *string `header:"style=simple,explode=false,name=X-Plex-Device-Vendor"`
	// A friendly name for the client
	DeviceName *string `header:"style=simple,explode=false,name=X-Plex-Device-Name"`
	// The marketplace on which the client application is distributed
	Marketplace *string `header:"style=simple,explode=false,name=X-Plex-Marketplace"`
}

func (r ReportGlobals) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *ReportGlobals) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (r *ReportGlobals) GetAccepts() *components.Accepts {
	if r == nil {
		return nil
	}
	return r.Accepts
}

func (r *ReportGlobals) GetClientIdentifier() *string {
	if r == nil {
		return nil
	}
	return r.ClientIdentifier
}

func (r *ReportGlobals) GetProduct() *string {
	if r == nil {
		return nil
	}
	return r.Product
}

func (r *ReportGlobals) GetVersion() *string {
	if r == nil {
		return nil
	}
	return r.Version
}

func (r *ReportGlobals) GetPlatform() *string {
	if r == nil {
		return nil
	}
	return r.Platform
}

func (r *ReportGlobals) GetPlatformVersion() *string {
	if r == nil {
		return nil
	}
	return r.PlatformVersion
}

func (r *ReportGlobals) GetDevice() *string {
	if r == nil {
		return nil
	}
	return r.Device
}

func (r *ReportGlobals) GetModel() *string {
	if r == nil {
		return nil
	}
	return r.Model
}

func (r *ReportGlobals) GetDeviceVendor() *string {
	if r == nil {
		return nil
	}
	return r.DeviceVendor
}

func (r *ReportGlobals) GetDeviceName() *string {
	if r == nil {
		return nil
	}
	return r.DeviceName
}

func (r *ReportGlobals) GetMarketplace() *string {
	if r == nil {
		return nil
	}
	return r.Marketplace
}

// State - The current state of the media.
type State string

const (
	StateStopped   State = "stopped"
	StateBuffering State = "buffering"
	StatePlaying   State = "playing"
	StatePaused    State = "paused"
)

func (e State) ToPointer() *State {
	return &e
}
func (e *State) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "stopped":
		fallthrough
	case "buffering":
		fallthrough
	case "playing":
		fallthrough
	case "paused":
		*e = State(v)
		return nil
	default:
		return fmt.Errorf("invalid value for State: %v", v)
	}
}

type ReportRequest struct {
	// Indicates the client accepts the indicated media types
	Accepts *components.Accepts `default:"application/xml" header:"style=simple,explode=false,name=accepts"`
	// An opaque identifier unique to the client
	ClientIdentifier *string `header:"style=simple,explode=false,name=X-Plex-Client-Identifier"`
	// The name of the client product
	Product *string `header:"style=simple,explode=false,name=X-Plex-Product"`
	// The version of the client application
	Version *string `header:"style=simple,explode=false,name=X-Plex-Version"`
	// The platform of the client
	Platform *string `header:"style=simple,explode=false,name=X-Plex-Platform"`
	// The version of the platform
	PlatformVersion *string `header:"style=simple,explode=false,name=X-Plex-Platform-Version"`
	// A relatively friendly name for the client device
	Device *string `header:"style=simple,explode=false,name=X-Plex-Device"`
	// A potentially less friendly identifier for the device model
	Model *string `header:"style=simple,explode=false,name=X-Plex-Model"`
	// The device vendor
	DeviceVendor *string `header:"style=simple,explode=false,name=X-Plex-Device-Vendor"`
	// A friendly name for the client
	DeviceName *string `header:"style=simple,explode=false,name=X-Plex-Device-Name"`
	// The marketplace on which the client application is distributed
	Marketplace *string `header:"style=simple,explode=false,name=X-Plex-Marketplace"`
	// The details key for the item.
	Key *string `queryParam:"style=form,explode=true,name=key"`
	// The rating key attribute for the item.
	RatingKey *string `queryParam:"style=form,explode=true,name=ratingKey"`
	// The current state of the media.
	State *State `queryParam:"style=form,explode=true,name=state"`
	// If playing media from a play queue, the play queue's ID.
	PlayQueueItemID *string `queryParam:"style=form,explode=true,name=playQueueItemID"`
	// The current time offset of playback in ms.
	Time *int64 `queryParam:"style=form,explode=true,name=time"`
	// The total duration of the item in ms.
	Duration *int64 `queryParam:"style=form,explode=true,name=duration"`
	// When state is `stopped`, a flag indicating whether or not the client is going to continue playing anothe item.
	Continuing *components.BoolInt `queryParam:"style=form,explode=true,name=continuing"`
	// Used when a sync client comes online and is syncing media timelines, holds the time at which the playback state was last updated.
	Updated *int64 `queryParam:"style=form,explode=true,name=updated"`
	// Also used by sync clients, used to indicate that a timeline is being synced from being offline, as opposed to being "live".
	Offline *components.BoolInt `queryParam:"style=form,explode=true,name=offline"`
	// Time in seconds till first frame is displayed.  Sent only on the first playing timeline request.
	TimeToFirstFrame *int64 `queryParam:"style=form,explode=true,name=timeToFirstFrame"`
	// Time in seconds spent buffering since last request.
	TimeStalled *int64 `queryParam:"style=form,explode=true,name=timeStalled"`
	// Bandwidth in kbps as estimated by the client.
	Bandwidth *int64 `queryParam:"style=form,explode=true,name=bandwidth"`
	// Amount of time in seconds buffered by client.  Omit if computed by `bufferedSize` below.
	BufferedTime *int64 `queryParam:"style=form,explode=true,name=bufferedTime"`
	// Size in kilobytes of data buffered by client.  Omit if computed by `bufferedTime` above
	BufferedSize *int64 `queryParam:"style=form,explode=true,name=bufferedSize"`
	// Unique per client playback session.  Used if a client can playback multiple items at a time (such as a browser with multiple tabs)
	XPlexSessionIdentifier *string `header:"style=simple,explode=false,name=X-Plex-Session-Identifier"`
}

func (r ReportRequest) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *ReportRequest) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (r *ReportRequest) GetAccepts() *components.Accepts {
	if r == nil {
		return nil
	}
	return r.Accepts
}

func (r *ReportRequest) GetClientIdentifier() *string {
	if r == nil {
		return nil
	}
	return r.ClientIdentifier
}

func (r *ReportRequest) GetProduct() *string {
	if r == nil {
		return nil
	}
	return r.Product
}

func (r *ReportRequest) GetVersion() *string {
	if r == nil {
		return nil
	}
	return r.Version
}

func (r *ReportRequest) GetPlatform() *string {
	if r == nil {
		return nil
	}
	return r.Platform
}

func (r *ReportRequest) GetPlatformVersion() *string {
	if r == nil {
		return nil
	}
	return r.PlatformVersion
}

func (r *ReportRequest) GetDevice() *string {
	if r == nil {
		return nil
	}
	return r.Device
}

func (r *ReportRequest) GetModel() *string {
	if r == nil {
		return nil
	}
	return r.Model
}

func (r *ReportRequest) GetDeviceVendor() *string {
	if r == nil {
		return nil
	}
	return r.DeviceVendor
}

func (r *ReportRequest) GetDeviceName() *string {
	if r == nil {
		return nil
	}
	return r.DeviceName
}

func (r *ReportRequest) GetMarketplace() *string {
	if r == nil {
		return nil
	}
	return r.Marketplace
}

func (r *ReportRequest) GetKey() *string {
	if r == nil {
		return nil
	}
	return r.Key
}

func (r *ReportRequest) GetRatingKey() *string {
	if r == nil {
		return nil
	}
	return r.RatingKey
}

func (r *ReportRequest) GetState() *State {
	if r == nil {
		return nil
	}
	return r.State
}

func (r *ReportRequest) GetPlayQueueItemID() *string {
	if r == nil {
		return nil
	}
	return r.PlayQueueItemID
}

func (r *ReportRequest) GetTime() *int64 {
	if r == nil {
		return nil
	}
	return r.Time
}

func (r *ReportRequest) GetDuration() *int64 {
	if r == nil {
		return nil
	}
	return r.Duration
}

func (r *ReportRequest) GetContinuing() *components.BoolInt {
	if r == nil {
		return nil
	}
	return r.Continuing
}

func (r *ReportRequest) GetUpdated() *int64 {
	if r == nil {
		return nil
	}
	return r.Updated
}

func (r *ReportRequest) GetOffline() *components.BoolInt {
	if r == nil {
		return nil
	}
	return r.Offline
}

func (r *ReportRequest) GetTimeToFirstFrame() *int64 {
	if r == nil {
		return nil
	}
	return r.TimeToFirstFrame
}

func (r *ReportRequest) GetTimeStalled() *int64 {
	if r == nil {
		return nil
	}
	return r.TimeStalled
}

func (r *ReportRequest) GetBandwidth() *int64 {
	if r == nil {
		return nil
	}
	return r.Bandwidth
}

func (r *ReportRequest) GetBufferedTime() *int64 {
	if r == nil {
		return nil
	}
	return r.BufferedTime
}

func (r *ReportRequest) GetBufferedSize() *int64 {
	if r == nil {
		return nil
	}
	return r.BufferedSize
}

func (r *ReportRequest) GetXPlexSessionIdentifier() *string {
	if r == nil {
		return nil
	}
	return r.XPlexSessionIdentifier
}

type Bandwidth struct {
	// The bandwidth at this time in kbps
	Bandwidth *int64 `json:"bandwidth,omitempty"`
	// The user-friendly resolution at this time
	Resolution *string `json:"resolution,omitempty"`
	// Media playback time where this bandwidth started
	Time *int64 `json:"time,omitempty"`
}

func (b *Bandwidth) GetBandwidth() *int64 {
	if b == nil {
		return nil
	}
	return b.Bandwidth
}

func (b *Bandwidth) GetResolution() *string {
	if b == nil {
		return nil
	}
	return b.Resolution
}

func (b *Bandwidth) GetTime() *int64 {
	if b == nil {
		return nil
	}
	return b.Time
}

// Bandwidths - A list of media times and bandwidths when trascoding is using with auto adjustment of bandwidth
type Bandwidths struct {
	Bandwidth []Bandwidth `json:"Bandwidth,omitempty"`
}

func (b *Bandwidths) GetBandwidth() []Bandwidth {
	if b == nil {
		return nil
	}
	return b.Bandwidth
}

// MediaContainer - `MediaContainer` is the root element of most Plex API responses. It serves as a generic container for various types of content (Metadata, Hubs, Directories, etc.) and includes pagination information (offset, size, totalSize) when applicable.
// Common attributes: - identifier: Unique identifier for this container - size: Number of items in this response page - totalSize: Total number of items available (for pagination) - offset: Starting index of this page (for pagination)
// The container often "hoists" common attributes from its children. For example, if all tracks in a container share the same album title, the `parentTitle` attribute may appear on the MediaContainer rather than being repeated on each track.
type MediaContainer struct {
	Identifier *string `json:"identifier,omitempty"`
	// The offset of where this container page starts among the total objects available. Also provided in the `X-Plex-Container-Start` header.
	//
	Offset *int64 `json:"offset,omitempty"`
	Size   *int64 `json:"size,omitempty"`
	// The total size of objects available. Also provided in the `X-Plex-Container-Total-Size` header.
	//
	TotalSize            *int64  `json:"totalSize,omitempty"`
	AllowCameraUpload    *bool   `json:"allowCameraUpload,omitempty"`
	AllowChannelAccess   *bool   `json:"allowChannelAccess,omitempty"`
	AllowMediaDeletion   *bool   `json:"allowMediaDeletion,omitempty"`
	AllowSharing         *bool   `json:"allowSharing,omitempty"`
	AllowSync            *bool   `json:"allowSync,omitempty"`
	AllowTuners          *bool   `json:"allowTuners,omitempty"`
	BackgroundProcessing *bool   `json:"backgroundProcessing,omitempty"`
	Certificate          *bool   `json:"certificate,omitempty"`
	CompanionProxy       *bool   `json:"companionProxy,omitempty"`
	CountryCode          *string `json:"countryCode,omitempty"`
	Diagnostics          *string `json:"diagnostics,omitempty"`
	EventStream          *bool   `json:"eventStream,omitempty"`
	FriendlyName         *string `json:"friendlyName,omitempty"`
	HubSearch            *bool   `json:"hubSearch,omitempty"`
	ItemClusters         *bool   `json:"itemClusters,omitempty"`
	Livetv               *int64  `json:"livetv,omitempty"`
	MachineIdentifier    any     `json:"machineIdentifier,omitempty"`
	MediaProviders       *bool   `json:"mediaProviders,omitempty"`
	Multiuser            *bool   `json:"multiuser,omitempty"`
	MusicAnalysis        *int64  `json:"musicAnalysis,omitempty"`
	MyPlex               *bool   `json:"myPlex,omitempty"`
	MyPlexMappingState   any     `json:"myPlexMappingState,omitempty"`
	MyPlexSigninState    any     `json:"myPlexSigninState,omitempty"`
	MyPlexSubscription   *bool   `json:"myPlexSubscription,omitempty"`
	MyPlexUsername       *string `json:"myPlexUsername,omitempty"`
	OfflineTranscode     any     `json:"offlineTranscode,omitempty"`
	// A comma-separated list of features which are enabled for the server owner
	OwnerFeatures                 *string `json:"ownerFeatures,omitempty"`
	Platform                      *string `json:"platform,omitempty"`
	PlatformVersion               *string `json:"platformVersion,omitempty"`
	PluginHost                    *bool   `json:"pluginHost,omitempty"`
	PushNotifications             *bool   `json:"pushNotifications,omitempty"`
	ReadOnlyLibraries             *bool   `json:"readOnlyLibraries,omitempty"`
	StreamingBrainABRVersion      *int64  `json:"streamingBrainABRVersion,omitempty"`
	StreamingBrainVersion         *int64  `json:"streamingBrainVersion,omitempty"`
	Sync                          *bool   `json:"sync,omitempty"`
	TranscoderActiveVideoSessions *int64  `json:"transcoderActiveVideoSessions,omitempty"`
	TranscoderAudio               *bool   `json:"transcoderAudio,omitempty"`
	TranscoderLyrics              *bool   `json:"transcoderLyrics,omitempty"`
	TranscoderPhoto               *bool   `json:"transcoderPhoto,omitempty"`
	TranscoderSubtitles           *bool   `json:"transcoderSubtitles,omitempty"`
	TranscoderVideo               *bool   `json:"transcoderVideo,omitempty"`
	// The suggested video quality bitrates to present to the user
	TranscoderVideoBitrates  any     `json:"transcoderVideoBitrates,omitempty"`
	TranscoderVideoQualities *string `json:"transcoderVideoQualities,omitempty"`
	// The suggested video resolutions to the above quality bitrates
	TranscoderVideoResolutions any     `json:"transcoderVideoResolutions,omitempty"`
	UpdatedAt                  *int64  `json:"updatedAt,omitempty"`
	Updater                    *bool   `json:"updater,omitempty"`
	Version                    *string `json:"version,omitempty"`
	VoiceSearch                *bool   `json:"voiceSearch,omitempty"`
	// A list of media times and bandwidths when trascoding is using with auto adjustment of bandwidth
	Bandwidths *Bandwidths `json:"Bandwidths,omitempty"`
	// A code describing why the session was terminated by the server.
	TerminationCode *int64 `json:"terminationCode,omitempty"`
	// A user friendly and localized text describing why the session was terminated by the server.
	TerminationText *string `json:"terminationText,omitempty"`
}

func (m *MediaContainer) GetIdentifier() *string {
	if m == nil {
		return nil
	}
	return m.Identifier
}

func (m *MediaContainer) GetOffset() *int64 {
	if m == nil {
		return nil
	}
	return m.Offset
}

func (m *MediaContainer) GetSize() *int64 {
	if m == nil {
		return nil
	}
	return m.Size
}

func (m *MediaContainer) GetTotalSize() *int64 {
	if m == nil {
		return nil
	}
	return m.TotalSize
}

func (m *MediaContainer) GetAllowCameraUpload() *bool {
	if m == nil {
		return nil
	}
	return m.AllowCameraUpload
}

func (m *MediaContainer) GetAllowChannelAccess() *bool {
	if m == nil {
		return nil
	}
	return m.AllowChannelAccess
}

func (m *MediaContainer) GetAllowMediaDeletion() *bool {
	if m == nil {
		return nil
	}
	return m.AllowMediaDeletion
}

func (m *MediaContainer) GetAllowSharing() *bool {
	if m == nil {
		return nil
	}
	return m.AllowSharing
}

func (m *MediaContainer) GetAllowSync() *bool {
	if m == nil {
		return nil
	}
	return m.AllowSync
}

func (m *MediaContainer) GetAllowTuners() *bool {
	if m == nil {
		return nil
	}
	return m.AllowTuners
}

func (m *MediaContainer) GetBackgroundProcessing() *bool {
	if m == nil {
		return nil
	}
	return m.BackgroundProcessing
}

func (m *MediaContainer) GetCertificate() *bool {
	if m == nil {
		return nil
	}
	return m.Certificate
}

func (m *MediaContainer) GetCompanionProxy() *bool {
	if m == nil {
		return nil
	}
	return m.CompanionProxy
}

func (m *MediaContainer) GetCountryCode() *string {
	if m == nil {
		return nil
	}
	return m.CountryCode
}

func (m *MediaContainer) GetDiagnostics() *string {
	if m == nil {
		return nil
	}
	return m.Diagnostics
}

func (m *MediaContainer) GetEventStream() *bool {
	if m == nil {
		return nil
	}
	return m.EventStream
}

func (m *MediaContainer) GetFriendlyName() *string {
	if m == nil {
		return nil
	}
	return m.FriendlyName
}

func (m *MediaContainer) GetHubSearch() *bool {
	if m == nil {
		return nil
	}
	return m.HubSearch
}

func (m *MediaContainer) GetItemClusters() *bool {
	if m == nil {
		return nil
	}
	return m.ItemClusters
}

func (m *MediaContainer) GetLivetv() *int64 {
	if m == nil {
		return nil
	}
	return m.Livetv
}

func (m *MediaContainer) GetMachineIdentifier() any {
	if m == nil {
		return nil
	}
	return m.MachineIdentifier
}

func (m *MediaContainer) GetMediaProviders() *bool {
	if m == nil {
		return nil
	}
	return m.MediaProviders
}

func (m *MediaContainer) GetMultiuser() *bool {
	if m == nil {
		return nil
	}
	return m.Multiuser
}

func (m *MediaContainer) GetMusicAnalysis() *int64 {
	if m == nil {
		return nil
	}
	return m.MusicAnalysis
}

func (m *MediaContainer) GetMyPlex() *bool {
	if m == nil {
		return nil
	}
	return m.MyPlex
}

func (m *MediaContainer) GetMyPlexMappingState() any {
	if m == nil {
		return nil
	}
	return m.MyPlexMappingState
}

func (m *MediaContainer) GetMyPlexSigninState() any {
	if m == nil {
		return nil
	}
	return m.MyPlexSigninState
}

func (m *MediaContainer) GetMyPlexSubscription() *bool {
	if m == nil {
		return nil
	}
	return m.MyPlexSubscription
}

func (m *MediaContainer) GetMyPlexUsername() *string {
	if m == nil {
		return nil
	}
	return m.MyPlexUsername
}

func (m *MediaContainer) GetOfflineTranscode() any {
	if m == nil {
		return nil
	}
	return m.OfflineTranscode
}

func (m *MediaContainer) GetOwnerFeatures() *string {
	if m == nil {
		return nil
	}
	return m.OwnerFeatures
}

func (m *MediaContainer) GetPlatform() *string {
	if m == nil {
		return nil
	}
	return m.Platform
}

func (m *MediaContainer) GetPlatformVersion() *string {
	if m == nil {
		return nil
	}
	return m.PlatformVersion
}

func (m *MediaContainer) GetPluginHost() *bool {
	if m == nil {
		return nil
	}
	return m.PluginHost
}

func (m *MediaContainer) GetPushNotifications() *bool {
	if m == nil {
		return nil
	}
	return m.PushNotifications
}

func (m *MediaContainer) GetReadOnlyLibraries() *bool {
	if m == nil {
		return nil
	}
	return m.ReadOnlyLibraries
}

func (m *MediaContainer) GetStreamingBrainABRVersion() *int64 {
	if m == nil {
		return nil
	}
	return m.StreamingBrainABRVersion
}

func (m *MediaContainer) GetStreamingBrainVersion() *int64 {
	if m == nil {
		return nil
	}
	return m.StreamingBrainVersion
}

func (m *MediaContainer) GetSync() *bool {
	if m == nil {
		return nil
	}
	return m.Sync
}

func (m *MediaContainer) GetTranscoderActiveVideoSessions() *int64 {
	if m == nil {
		return nil
	}
	return m.TranscoderActiveVideoSessions
}

func (m *MediaContainer) GetTranscoderAudio() *bool {
	if m == nil {
		return nil
	}
	return m.TranscoderAudio
}

func (m *MediaContainer) GetTranscoderLyrics() *bool {
	if m == nil {
		return nil
	}
	return m.TranscoderLyrics
}

func (m *MediaContainer) GetTranscoderPhoto() *bool {
	if m == nil {
		return nil
	}
	return m.TranscoderPhoto
}

func (m *MediaContainer) GetTranscoderSubtitles() *bool {
	if m == nil {
		return nil
	}
	return m.TranscoderSubtitles
}

func (m *MediaContainer) GetTranscoderVideo() *bool {
	if m == nil {
		return nil
	}
	return m.TranscoderVideo
}

func (m *MediaContainer) GetTranscoderVideoBitrates() any {
	if m == nil {
		return nil
	}
	return m.TranscoderVideoBitrates
}

func (m *MediaContainer) GetTranscoderVideoQualities() *string {
	if m == nil {
		return nil
	}
	return m.TranscoderVideoQualities
}

func (m *MediaContainer) GetTranscoderVideoResolutions() any {
	if m == nil {
		return nil
	}
	return m.TranscoderVideoResolutions
}

func (m *MediaContainer) GetUpdatedAt() *int64 {
	if m == nil {
		return nil
	}
	return m.UpdatedAt
}

func (m *MediaContainer) GetUpdater() *bool {
	if m == nil {
		return nil
	}
	return m.Updater
}

func (m *MediaContainer) GetVersion() *string {
	if m == nil {
		return nil
	}
	return m.Version
}

func (m *MediaContainer) GetVoiceSearch() *bool {
	if m == nil {
		return nil
	}
	return m.VoiceSearch
}

func (m *MediaContainer) GetBandwidths() *Bandwidths {
	if m == nil {
		return nil
	}
	return m.Bandwidths
}

func (m *MediaContainer) GetTerminationCode() *int64 {
	if m == nil {
		return nil
	}
	return m.TerminationCode
}

func (m *MediaContainer) GetTerminationText() *string {
	if m == nil {
		return nil
	}
	return m.TerminationText
}

// ReportResponseBody - OK
type ReportResponseBody struct {
	MediaContainer *MediaContainer `json:"MediaContainer,omitempty"`
}

func (r *ReportResponseBody) GetMediaContainer() *MediaContainer {
	if r == nil {
		return nil
	}
	return r.MediaContainer
}

type ReportResponse struct {
	// HTTP response content type for this operation
	ContentType string
	// HTTP response status code for this operation
	StatusCode int
	// Raw HTTP response; suitable for custom response parsing
	RawResponse *http.Response
	// OK
	Object *ReportResponseBody
}

func (r *ReportResponse) GetContentType() string {
	if r == nil {
		return ""
	}
	return r.ContentType
}

func (r *ReportResponse) GetStatusCode() int {
	if r == nil {
		return 0
	}
	return r.StatusCode
}

func (r *ReportResponse) GetRawResponse() *http.Response {
	if r == nil {
		return nil
	}
	return r.RawResponse
}

func (r *ReportResponse) GetObject() *ReportResponseBody {
	if r == nil {
		return nil
	}
	return r.Object
}
