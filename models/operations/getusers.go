// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"github.com/LukeHagar/plexgo/internal/utils"
	"net/http"
)

var GetUsersServerList = []string{
	"https://plex.tv/api",
}

type GetUsersRequest struct {
	// An opaque identifier unique to the client (UUID, serial number, or other unique device ID)
	ClientID string `header:"style=simple,explode=false,name=X-Plex-Client-Identifier"`
	// The name of the client application. (Plex Web, Plex Media Server, etc.)
	ClientName *string `header:"style=simple,explode=false,name=X-Plex-Product"`
	// A relatively friendly name for the client device
	DeviceNickname *string `header:"style=simple,explode=false,name=X-Plex-Device"`
	// The name of the device the client application is running on. This is used to track the client application and its usage. (Chrome, Safari, etc.)
	DeviceName *string `header:"style=simple,explode=false,name=X-Plex-Device-Name"`
	// The resolution of the device the client application is running on. This is used to track the client application and its usage. (1487x1165,2560x1440)
	DeviceScreenResolution *string `header:"style=simple,explode=false,name=X-Plex-Device-Screen-Resolution"`
	// The version of the client application.
	ClientVersion *string `header:"style=simple,explode=false,name=X-Plex-Version"`
	// The platform of the client application.
	Platform *string `header:"style=simple,explode=false,name=X-Plex-Platform"`
	// The features of the client application. This is used to track the client application and its usage. (external-media,indirect-media,hub-style-list)
	ClientFeatures *string `header:"style=simple,explode=false,name=X-Plex-Features"`
	// A potentially less friendly identifier for the device model
	Model *string `header:"style=simple,explode=false,name=X-Plex-Model"`
	// The session ID of the client application. This is used to track the client application and its usage. (97e136ef-4ddd-4ff3-89a7-a5820c96c2ca)
	XPlexSessionID *string `header:"style=simple,explode=false,name=X-Plex-Session-Id"`
	// The language of the client application.
	XPlexLanguage *string `header:"style=simple,explode=false,name=X-Plex-Language"`
	// The version of the platform
	PlatformVersion *string `header:"style=simple,explode=false,name=X-Plex-Platform-Version"`
	// An authentication token, obtained from plex.tv
	XPlexToken string `header:"style=simple,explode=false,name=X-Plex-Token"`
}

func (g *GetUsersRequest) GetClientID() string {
	if g == nil {
		return ""
	}
	return g.ClientID
}

func (g *GetUsersRequest) GetClientName() *string {
	if g == nil {
		return nil
	}
	return g.ClientName
}

func (g *GetUsersRequest) GetDeviceNickname() *string {
	if g == nil {
		return nil
	}
	return g.DeviceNickname
}

func (g *GetUsersRequest) GetDeviceName() *string {
	if g == nil {
		return nil
	}
	return g.DeviceName
}

func (g *GetUsersRequest) GetDeviceScreenResolution() *string {
	if g == nil {
		return nil
	}
	return g.DeviceScreenResolution
}

func (g *GetUsersRequest) GetClientVersion() *string {
	if g == nil {
		return nil
	}
	return g.ClientVersion
}

func (g *GetUsersRequest) GetPlatform() *string {
	if g == nil {
		return nil
	}
	return g.Platform
}

func (g *GetUsersRequest) GetClientFeatures() *string {
	if g == nil {
		return nil
	}
	return g.ClientFeatures
}

func (g *GetUsersRequest) GetModel() *string {
	if g == nil {
		return nil
	}
	return g.Model
}

func (g *GetUsersRequest) GetXPlexSessionID() *string {
	if g == nil {
		return nil
	}
	return g.XPlexSessionID
}

func (g *GetUsersRequest) GetXPlexLanguage() *string {
	if g == nil {
		return nil
	}
	return g.XPlexLanguage
}

func (g *GetUsersRequest) GetPlatformVersion() *string {
	if g == nil {
		return nil
	}
	return g.PlatformVersion
}

func (g *GetUsersRequest) GetXPlexToken() string {
	if g == nil {
		return ""
	}
	return g.XPlexToken
}

// Protected - Indicates whether the account is protected.
type Protected int

const (
	ProtectedDisable Protected = 0
	ProtectedEnable  Protected = 1
)

func (e Protected) ToPointer() *Protected {
	return &e
}
func (e *Protected) UnmarshalJSON(data []byte) error {
	var v int
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 0:
		fallthrough
	case 1:
		*e = Protected(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Protected: %v", v)
	}
}

// Home - Indicates if the user is part of a home group.
type Home int

const (
	HomeDisable Home = 0
	HomeEnable  Home = 1
)

func (e Home) ToPointer() *Home {
	return &e
}
func (e *Home) UnmarshalJSON(data []byte) error {
	var v int
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 0:
		fallthrough
	case 1:
		*e = Home(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Home: %v", v)
	}
}

// AllowTuners - Indicates if the user is allowed to use tuners.
type AllowTuners int

const (
	AllowTunersDisable AllowTuners = 0
	AllowTunersEnable  AllowTuners = 1
)

func (e AllowTuners) ToPointer() *AllowTuners {
	return &e
}
func (e *AllowTuners) UnmarshalJSON(data []byte) error {
	var v int
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 0:
		fallthrough
	case 1:
		*e = AllowTuners(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AllowTuners: %v", v)
	}
}

// AllowSync - Indicates if the user is allowed to sync media.
type AllowSync int

const (
	AllowSyncDisable AllowSync = 0
	AllowSyncEnable  AllowSync = 1
)

func (e AllowSync) ToPointer() *AllowSync {
	return &e
}
func (e *AllowSync) UnmarshalJSON(data []byte) error {
	var v int
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 0:
		fallthrough
	case 1:
		*e = AllowSync(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AllowSync: %v", v)
	}
}

// AllowCameraUpload - Indicates if the user is allowed to upload from a camera.
type AllowCameraUpload int

const (
	AllowCameraUploadDisable AllowCameraUpload = 0
	AllowCameraUploadEnable  AllowCameraUpload = 1
)

func (e AllowCameraUpload) ToPointer() *AllowCameraUpload {
	return &e
}
func (e *AllowCameraUpload) UnmarshalJSON(data []byte) error {
	var v int
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 0:
		fallthrough
	case 1:
		*e = AllowCameraUpload(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AllowCameraUpload: %v", v)
	}
}

// AllowChannels - Indicates if the user has access to channels.
type AllowChannels int

const (
	AllowChannelsDisable AllowChannels = 0
	AllowChannelsEnable  AllowChannels = 1
)

func (e AllowChannels) ToPointer() *AllowChannels {
	return &e
}
func (e *AllowChannels) UnmarshalJSON(data []byte) error {
	var v int
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 0:
		fallthrough
	case 1:
		*e = AllowChannels(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AllowChannels: %v", v)
	}
}

// AllowSubtitleAdmin - Indicates if the user can manage subtitles.
type AllowSubtitleAdmin int

const (
	AllowSubtitleAdminDisable AllowSubtitleAdmin = 0
	AllowSubtitleAdminEnable  AllowSubtitleAdmin = 1
)

func (e AllowSubtitleAdmin) ToPointer() *AllowSubtitleAdmin {
	return &e
}
func (e *AllowSubtitleAdmin) UnmarshalJSON(data []byte) error {
	var v int
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 0:
		fallthrough
	case 1:
		*e = AllowSubtitleAdmin(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AllowSubtitleAdmin: %v", v)
	}
}

// Restricted - Indicates if the user has restricted access.
type Restricted int

const (
	RestrictedDisable Restricted = 0
	RestrictedEnable  Restricted = 1
)

func (e Restricted) ToPointer() *Restricted {
	return &e
}
func (e *Restricted) UnmarshalJSON(data []byte) error {
	var v int
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 0:
		fallthrough
	case 1:
		*e = Restricted(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Restricted: %v", v)
	}
}

// AllLibraries - Indicates if the user has access to all libraries.
type AllLibraries int

const (
	AllLibrariesDisable AllLibraries = 0
	AllLibrariesEnable  AllLibraries = 1
)

func (e AllLibraries) ToPointer() *AllLibraries {
	return &e
}
func (e *AllLibraries) UnmarshalJSON(data []byte) error {
	var v int
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 0:
		fallthrough
	case 1:
		*e = AllLibraries(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AllLibraries: %v", v)
	}
}

// Owned - Indicates if the user owns the server.
type Owned int

const (
	OwnedDisable Owned = 0
	OwnedEnable  Owned = 1
)

func (e Owned) ToPointer() *Owned {
	return &e
}
func (e *Owned) UnmarshalJSON(data []byte) error {
	var v int
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 0:
		fallthrough
	case 1:
		*e = Owned(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Owned: %v", v)
	}
}

// Pending - Indicates if the server is pending approval.
type Pending int

const (
	PendingDisable Pending = 0
	PendingEnable  Pending = 1
)

func (e Pending) ToPointer() *Pending {
	return &e
}
func (e *Pending) UnmarshalJSON(data []byte) error {
	var v int
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 0:
		fallthrough
	case 1:
		*e = Pending(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Pending: %v", v)
	}
}

type GetUsersServer struct {
	// Unique ID of the server of the connected user
	ID int64
	// ID of the actual Plex server.
	ServerID int64
	// Machine identifier of the Plex server.
	MachineIdentifier string
	// Name of the Plex server of the connected user.
	Name       string
	LastSeenAt int64
	// Number of libraries in the server this user has access to.
	NumLibraries int64
	AllLibraries *AllLibraries `default:"0"`
	Owned        *Owned        `default:"0"`
	Pending      *Pending      `default:"0"`
}

func (g GetUsersServer) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetUsersServer) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"id", "serverId", "machineIdentifier", "name", "lastSeenAt", "numLibraries"}); err != nil {
		return err
	}
	return nil
}

func (g *GetUsersServer) GetID() int64 {
	if g == nil {
		return 0
	}
	return g.ID
}

func (g *GetUsersServer) GetServerID() int64 {
	if g == nil {
		return 0
	}
	return g.ServerID
}

func (g *GetUsersServer) GetMachineIdentifier() string {
	if g == nil {
		return ""
	}
	return g.MachineIdentifier
}

func (g *GetUsersServer) GetName() string {
	if g == nil {
		return ""
	}
	return g.Name
}

func (g *GetUsersServer) GetLastSeenAt() int64 {
	if g == nil {
		return 0
	}
	return g.LastSeenAt
}

func (g *GetUsersServer) GetNumLibraries() int64 {
	if g == nil {
		return 0
	}
	return g.NumLibraries
}

func (g *GetUsersServer) GetAllLibraries() *AllLibraries {
	if g == nil {
		return nil
	}
	return g.AllLibraries
}

func (g *GetUsersServer) GetOwned() *Owned {
	if g == nil {
		return nil
	}
	return g.Owned
}

func (g *GetUsersServer) GetPending() *Pending {
	if g == nil {
		return nil
	}
	return g.Pending
}

type User struct {
	// User's unique ID.
	ID int64
	// User's display name.
	Title string
	// User's username.
	Username string
	// User's email address.
	Email string
	// ID of the user's recommendation playlist.
	RecommendationsPlaylistID *string
	// URL to the user's avatar image.
	Thumb              string
	Protected          *Protected          `default:"0"`
	Home               *Home               `default:"0"`
	AllowTuners        *AllowTuners        `default:"0"`
	AllowSync          *AllowSync          `default:"0"`
	AllowCameraUpload  *AllowCameraUpload  `default:"0"`
	AllowChannels      *AllowChannels      `default:"0"`
	AllowSubtitleAdmin *AllowSubtitleAdmin `default:"0"`
	// Filters applied for all content.
	FilterAll *string
	// Filters applied for movies.
	FilterMovies *string
	// Filters applied for music.
	FilterMusic *string
	// Filters applied for photos.
	FilterPhotos *string
	// Filters applied for television.
	FilterTelevision *string
	Restricted       *Restricted `default:"0"`
	// List of servers owned by the user.
	Server []GetUsersServer
}

func (u User) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(u, "", false)
}

func (u *User) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &u, "", false, []string{"id", "title", "username", "email", "thumb", "Server"}); err != nil {
		return err
	}
	return nil
}

func (u *User) GetID() int64 {
	if u == nil {
		return 0
	}
	return u.ID
}

func (u *User) GetTitle() string {
	if u == nil {
		return ""
	}
	return u.Title
}

func (u *User) GetUsername() string {
	if u == nil {
		return ""
	}
	return u.Username
}

func (u *User) GetEmail() string {
	if u == nil {
		return ""
	}
	return u.Email
}

func (u *User) GetRecommendationsPlaylistID() *string {
	if u == nil {
		return nil
	}
	return u.RecommendationsPlaylistID
}

func (u *User) GetThumb() string {
	if u == nil {
		return ""
	}
	return u.Thumb
}

func (u *User) GetProtected() *Protected {
	if u == nil {
		return nil
	}
	return u.Protected
}

func (u *User) GetHome() *Home {
	if u == nil {
		return nil
	}
	return u.Home
}

func (u *User) GetAllowTuners() *AllowTuners {
	if u == nil {
		return nil
	}
	return u.AllowTuners
}

func (u *User) GetAllowSync() *AllowSync {
	if u == nil {
		return nil
	}
	return u.AllowSync
}

func (u *User) GetAllowCameraUpload() *AllowCameraUpload {
	if u == nil {
		return nil
	}
	return u.AllowCameraUpload
}

func (u *User) GetAllowChannels() *AllowChannels {
	if u == nil {
		return nil
	}
	return u.AllowChannels
}

func (u *User) GetAllowSubtitleAdmin() *AllowSubtitleAdmin {
	if u == nil {
		return nil
	}
	return u.AllowSubtitleAdmin
}

func (u *User) GetFilterAll() *string {
	if u == nil {
		return nil
	}
	return u.FilterAll
}

func (u *User) GetFilterMovies() *string {
	if u == nil {
		return nil
	}
	return u.FilterMovies
}

func (u *User) GetFilterMusic() *string {
	if u == nil {
		return nil
	}
	return u.FilterMusic
}

func (u *User) GetFilterPhotos() *string {
	if u == nil {
		return nil
	}
	return u.FilterPhotos
}

func (u *User) GetFilterTelevision() *string {
	if u == nil {
		return nil
	}
	return u.FilterTelevision
}

func (u *User) GetRestricted() *Restricted {
	if u == nil {
		return nil
	}
	return u.Restricted
}

func (u *User) GetServer() []GetUsersServer {
	if u == nil {
		return []GetUsersServer{}
	}
	return u.Server
}

// GetUsersMediaContainer - Container holding user and server details.
type GetUsersMediaContainer struct {
	// The friendly name of the Plex instance.
	FriendlyName string
	Identifier   string
	// Unique Machine identifier of the Plex server.
	MachineIdentifier string
	// Total number of users.
	TotalSize int64
	// Number of users in the current response.
	Size int64
	// List of users with access to the Plex server.
	User []User
}

func (g *GetUsersMediaContainer) GetFriendlyName() string {
	if g == nil {
		return ""
	}
	return g.FriendlyName
}

func (g *GetUsersMediaContainer) GetIdentifier() string {
	if g == nil {
		return ""
	}
	return g.Identifier
}

func (g *GetUsersMediaContainer) GetMachineIdentifier() string {
	if g == nil {
		return ""
	}
	return g.MachineIdentifier
}

func (g *GetUsersMediaContainer) GetTotalSize() int64 {
	if g == nil {
		return 0
	}
	return g.TotalSize
}

func (g *GetUsersMediaContainer) GetSize() int64 {
	if g == nil {
		return 0
	}
	return g.Size
}

func (g *GetUsersMediaContainer) GetUser() []User {
	if g == nil {
		return []User{}
	}
	return g.User
}

// GetUsersResponseBody - Successful response with media container data in XML
type GetUsersResponseBody struct {
	// Container holding user and server details.
	MediaContainer *GetUsersMediaContainer
}

func (g *GetUsersResponseBody) GetMediaContainer() *GetUsersMediaContainer {
	if g == nil {
		return nil
	}
	return g.MediaContainer
}

type GetUsersResponse struct {
	// HTTP response content type for this operation
	ContentType string
	// HTTP response status code for this operation
	StatusCode int
	// Raw HTTP response; suitable for custom response parsing
	RawResponse *http.Response
	Body        []byte
}

func (g *GetUsersResponse) GetContentType() string {
	if g == nil {
		return ""
	}
	return g.ContentType
}

func (g *GetUsersResponse) GetStatusCode() int {
	if g == nil {
		return 0
	}
	return g.StatusCode
}

func (g *GetUsersResponse) GetRawResponse() *http.Response {
	if g == nil {
		return nil
	}
	return g.RawResponse
}

func (g *GetUsersResponse) GetBody() []byte {
	if g == nil {
		return nil
	}
	return g.Body
}
