// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"github.com/LukeHagar/plexgo/internal/utils"
	"github.com/LukeHagar/plexgo/models/components"
	"net/http"
)

var GetUsersServerList = []string{
	"https://plex.tv/api",
}

type GetUsersGlobals struct {
	// Indicates the client accepts the indicated media types
	Accepts *components.Accepts `default:"application/xml" header:"style=simple,explode=false,name=accepts"`
	// An opaque identifier unique to the client
	ClientIdentifier *string `header:"style=simple,explode=false,name=X-Plex-Client-Identifier"`
	// The name of the client product
	Product *string `header:"style=simple,explode=false,name=X-Plex-Product"`
	// The version of the client application
	Version *string `header:"style=simple,explode=false,name=X-Plex-Version"`
	// The platform of the client
	Platform *string `header:"style=simple,explode=false,name=X-Plex-Platform"`
	// The version of the platform
	PlatformVersion *string `header:"style=simple,explode=false,name=X-Plex-Platform-Version"`
	// A relatively friendly name for the client device
	Device *string `header:"style=simple,explode=false,name=X-Plex-Device"`
	// A potentially less friendly identifier for the device model
	Model *string `header:"style=simple,explode=false,name=X-Plex-Model"`
	// The device vendor
	DeviceVendor *string `header:"style=simple,explode=false,name=X-Plex-Device-Vendor"`
	// A friendly name for the client
	DeviceName *string `header:"style=simple,explode=false,name=X-Plex-Device-Name"`
	// The marketplace on which the client application is distributed
	Marketplace *string `header:"style=simple,explode=false,name=X-Plex-Marketplace"`
}

func (g GetUsersGlobals) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetUsersGlobals) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (g *GetUsersGlobals) GetAccepts() *components.Accepts {
	if g == nil {
		return nil
	}
	return g.Accepts
}

func (g *GetUsersGlobals) GetClientIdentifier() *string {
	if g == nil {
		return nil
	}
	return g.ClientIdentifier
}

func (g *GetUsersGlobals) GetProduct() *string {
	if g == nil {
		return nil
	}
	return g.Product
}

func (g *GetUsersGlobals) GetVersion() *string {
	if g == nil {
		return nil
	}
	return g.Version
}

func (g *GetUsersGlobals) GetPlatform() *string {
	if g == nil {
		return nil
	}
	return g.Platform
}

func (g *GetUsersGlobals) GetPlatformVersion() *string {
	if g == nil {
		return nil
	}
	return g.PlatformVersion
}

func (g *GetUsersGlobals) GetDevice() *string {
	if g == nil {
		return nil
	}
	return g.Device
}

func (g *GetUsersGlobals) GetModel() *string {
	if g == nil {
		return nil
	}
	return g.Model
}

func (g *GetUsersGlobals) GetDeviceVendor() *string {
	if g == nil {
		return nil
	}
	return g.DeviceVendor
}

func (g *GetUsersGlobals) GetDeviceName() *string {
	if g == nil {
		return nil
	}
	return g.DeviceName
}

func (g *GetUsersGlobals) GetMarketplace() *string {
	if g == nil {
		return nil
	}
	return g.Marketplace
}

type GetUsersRequest struct {
	// Indicates the client accepts the indicated media types
	Accepts *components.Accepts `default:"application/xml" header:"style=simple,explode=false,name=accepts"`
	// An opaque identifier unique to the client
	ClientIdentifier *string `header:"style=simple,explode=false,name=X-Plex-Client-Identifier"`
	// The name of the client product
	Product *string `header:"style=simple,explode=false,name=X-Plex-Product"`
	// The version of the client application
	Version *string `header:"style=simple,explode=false,name=X-Plex-Version"`
	// The platform of the client
	Platform *string `header:"style=simple,explode=false,name=X-Plex-Platform"`
	// The version of the platform
	PlatformVersion *string `header:"style=simple,explode=false,name=X-Plex-Platform-Version"`
	// A relatively friendly name for the client device
	Device *string `header:"style=simple,explode=false,name=X-Plex-Device"`
	// A potentially less friendly identifier for the device model
	Model *string `header:"style=simple,explode=false,name=X-Plex-Model"`
	// The device vendor
	DeviceVendor *string `header:"style=simple,explode=false,name=X-Plex-Device-Vendor"`
	// A friendly name for the client
	DeviceName *string `header:"style=simple,explode=false,name=X-Plex-Device-Name"`
	// The marketplace on which the client application is distributed
	Marketplace *string `header:"style=simple,explode=false,name=X-Plex-Marketplace"`
}

func (g GetUsersRequest) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetUsersRequest) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (g *GetUsersRequest) GetAccepts() *components.Accepts {
	if g == nil {
		return nil
	}
	return g.Accepts
}

func (g *GetUsersRequest) GetClientIdentifier() *string {
	if g == nil {
		return nil
	}
	return g.ClientIdentifier
}

func (g *GetUsersRequest) GetProduct() *string {
	if g == nil {
		return nil
	}
	return g.Product
}

func (g *GetUsersRequest) GetVersion() *string {
	if g == nil {
		return nil
	}
	return g.Version
}

func (g *GetUsersRequest) GetPlatform() *string {
	if g == nil {
		return nil
	}
	return g.Platform
}

func (g *GetUsersRequest) GetPlatformVersion() *string {
	if g == nil {
		return nil
	}
	return g.PlatformVersion
}

func (g *GetUsersRequest) GetDevice() *string {
	if g == nil {
		return nil
	}
	return g.Device
}

func (g *GetUsersRequest) GetModel() *string {
	if g == nil {
		return nil
	}
	return g.Model
}

func (g *GetUsersRequest) GetDeviceVendor() *string {
	if g == nil {
		return nil
	}
	return g.DeviceVendor
}

func (g *GetUsersRequest) GetDeviceName() *string {
	if g == nil {
		return nil
	}
	return g.DeviceName
}

func (g *GetUsersRequest) GetMarketplace() *string {
	if g == nil {
		return nil
	}
	return g.Marketplace
}

// Protected - Indicates whether the account is protected.
type Protected int

const (
	ProtectedDisable Protected = 0
	ProtectedEnable  Protected = 1
)

func (e Protected) ToPointer() *Protected {
	return &e
}
func (e *Protected) UnmarshalJSON(data []byte) error {
	var v int
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 0:
		fallthrough
	case 1:
		*e = Protected(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Protected: %v", v)
	}
}

// Home - Indicates if the user is part of a home group.
type Home int

const (
	HomeDisable Home = 0
	HomeEnable  Home = 1
)

func (e Home) ToPointer() *Home {
	return &e
}
func (e *Home) UnmarshalJSON(data []byte) error {
	var v int
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 0:
		fallthrough
	case 1:
		*e = Home(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Home: %v", v)
	}
}

// AllowTuners - Indicates if the user is allowed to use tuners.
type AllowTuners int

const (
	AllowTunersDisable AllowTuners = 0
	AllowTunersEnable  AllowTuners = 1
)

func (e AllowTuners) ToPointer() *AllowTuners {
	return &e
}
func (e *AllowTuners) UnmarshalJSON(data []byte) error {
	var v int
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 0:
		fallthrough
	case 1:
		*e = AllowTuners(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AllowTuners: %v", v)
	}
}

// AllowSync - Indicates if the user is allowed to sync media.
type AllowSync int

const (
	AllowSyncDisable AllowSync = 0
	AllowSyncEnable  AllowSync = 1
)

func (e AllowSync) ToPointer() *AllowSync {
	return &e
}
func (e *AllowSync) UnmarshalJSON(data []byte) error {
	var v int
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 0:
		fallthrough
	case 1:
		*e = AllowSync(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AllowSync: %v", v)
	}
}

// AllowCameraUpload - Indicates if the user is allowed to upload from a camera.
type AllowCameraUpload int

const (
	AllowCameraUploadDisable AllowCameraUpload = 0
	AllowCameraUploadEnable  AllowCameraUpload = 1
)

func (e AllowCameraUpload) ToPointer() *AllowCameraUpload {
	return &e
}
func (e *AllowCameraUpload) UnmarshalJSON(data []byte) error {
	var v int
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 0:
		fallthrough
	case 1:
		*e = AllowCameraUpload(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AllowCameraUpload: %v", v)
	}
}

// AllowChannels - Indicates if the user has access to channels.
type AllowChannels int

const (
	AllowChannelsDisable AllowChannels = 0
	AllowChannelsEnable  AllowChannels = 1
)

func (e AllowChannels) ToPointer() *AllowChannels {
	return &e
}
func (e *AllowChannels) UnmarshalJSON(data []byte) error {
	var v int
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 0:
		fallthrough
	case 1:
		*e = AllowChannels(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AllowChannels: %v", v)
	}
}

// AllowSubtitleAdmin - Indicates if the user can manage subtitles.
type AllowSubtitleAdmin int

const (
	AllowSubtitleAdminDisable AllowSubtitleAdmin = 0
	AllowSubtitleAdminEnable  AllowSubtitleAdmin = 1
)

func (e AllowSubtitleAdmin) ToPointer() *AllowSubtitleAdmin {
	return &e
}
func (e *AllowSubtitleAdmin) UnmarshalJSON(data []byte) error {
	var v int
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 0:
		fallthrough
	case 1:
		*e = AllowSubtitleAdmin(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AllowSubtitleAdmin: %v", v)
	}
}

// Restricted - Indicates if the user has restricted access.
type Restricted int

const (
	RestrictedDisable Restricted = 0
	RestrictedEnable  Restricted = 1
)

func (e Restricted) ToPointer() *Restricted {
	return &e
}
func (e *Restricted) UnmarshalJSON(data []byte) error {
	var v int
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 0:
		fallthrough
	case 1:
		*e = Restricted(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Restricted: %v", v)
	}
}

// AllLibraries - Indicates if the user has access to all libraries.
type AllLibraries int

const (
	AllLibrariesDisable AllLibraries = 0
	AllLibrariesEnable  AllLibraries = 1
)

func (e AllLibraries) ToPointer() *AllLibraries {
	return &e
}
func (e *AllLibraries) UnmarshalJSON(data []byte) error {
	var v int
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 0:
		fallthrough
	case 1:
		*e = AllLibraries(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AllLibraries: %v", v)
	}
}

// Owned - Indicates if the user owns the server.
type Owned int

const (
	OwnedDisable Owned = 0
	OwnedEnable  Owned = 1
)

func (e Owned) ToPointer() *Owned {
	return &e
}
func (e *Owned) UnmarshalJSON(data []byte) error {
	var v int
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 0:
		fallthrough
	case 1:
		*e = Owned(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Owned: %v", v)
	}
}

// Pending - Indicates if the server is pending approval.
type Pending int

const (
	PendingDisable Pending = 0
	PendingEnable  Pending = 1
)

func (e Pending) ToPointer() *Pending {
	return &e
}
func (e *Pending) UnmarshalJSON(data []byte) error {
	var v int
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 0:
		fallthrough
	case 1:
		*e = Pending(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Pending: %v", v)
	}
}

type Server struct {
	// Unique ID of the server of the connected user
	ID int64 `json:"id"`
	// ID of the actual Plex server.
	ServerID int64 `json:"serverId"`
	// Machine identifier of the Plex server.
	MachineIdentifier string `json:"machineIdentifier"`
	// Name of the Plex server of the connected user.
	Name string `json:"name"`
	// Unix epoch datetime in seconds
	LastSeenAt int64 `json:"lastSeenAt"`
	// Number of libraries in the server this user has access to.
	NumLibraries int64         `json:"numLibraries"`
	AllLibraries *AllLibraries `default:"0" json:"allLibraries"`
	Owned        *Owned        `default:"0" json:"owned"`
	Pending      *Pending      `default:"0" json:"pending"`
}

func (s Server) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *Server) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"id", "serverId", "machineIdentifier", "name", "lastSeenAt", "numLibraries"}); err != nil {
		return err
	}
	return nil
}

func (s *Server) GetID() int64 {
	if s == nil {
		return 0
	}
	return s.ID
}

func (s *Server) GetServerID() int64 {
	if s == nil {
		return 0
	}
	return s.ServerID
}

func (s *Server) GetMachineIdentifier() string {
	if s == nil {
		return ""
	}
	return s.MachineIdentifier
}

func (s *Server) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *Server) GetLastSeenAt() int64 {
	if s == nil {
		return 0
	}
	return s.LastSeenAt
}

func (s *Server) GetNumLibraries() int64 {
	if s == nil {
		return 0
	}
	return s.NumLibraries
}

func (s *Server) GetAllLibraries() *AllLibraries {
	if s == nil {
		return nil
	}
	return s.AllLibraries
}

func (s *Server) GetOwned() *Owned {
	if s == nil {
		return nil
	}
	return s.Owned
}

func (s *Server) GetPending() *Pending {
	if s == nil {
		return nil
	}
	return s.Pending
}

type User struct {
	// User's unique ID.
	ID int64 `json:"id"`
	// User's display name.
	Title string `json:"title"`
	// User's username.
	Username string `json:"username"`
	// User's email address.
	Email string `json:"email"`
	// ID of the user's recommendation playlist.
	RecommendationsPlaylistID *string `json:"recommendationsPlaylistId,omitempty"`
	// URL to the user's avatar image.
	Thumb              string              `json:"thumb"`
	Protected          *Protected          `default:"0" json:"protected"`
	Home               *Home               `default:"0" json:"home"`
	AllowTuners        *AllowTuners        `default:"0" json:"allowTuners"`
	AllowSync          *AllowSync          `default:"0" json:"allowSync"`
	AllowCameraUpload  *AllowCameraUpload  `default:"0" json:"allowCameraUpload"`
	AllowChannels      *AllowChannels      `default:"0" json:"allowChannels"`
	AllowSubtitleAdmin *AllowSubtitleAdmin `default:"0" json:"allowSubtitleAdmin"`
	// Filters applied for all content.
	FilterAll *string `json:"filterAll,omitempty"`
	// Filters applied for movies.
	FilterMovies *string `json:"filterMovies,omitempty"`
	// Filters applied for music.
	FilterMusic *string `json:"filterMusic,omitempty"`
	// Filters applied for photos.
	FilterPhotos *string `json:"filterPhotos,omitempty"`
	// Filters applied for television.
	FilterTelevision *string     `json:"filterTelevision,omitempty"`
	Restricted       *Restricted `default:"0" json:"restricted"`
	// List of servers owned by the user.
	Server []Server `json:"Server"`
}

func (u User) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(u, "", false)
}

func (u *User) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &u, "", false, []string{"id", "title", "username", "email", "thumb", "Server"}); err != nil {
		return err
	}
	return nil
}

func (u *User) GetID() int64 {
	if u == nil {
		return 0
	}
	return u.ID
}

func (u *User) GetTitle() string {
	if u == nil {
		return ""
	}
	return u.Title
}

func (u *User) GetUsername() string {
	if u == nil {
		return ""
	}
	return u.Username
}

func (u *User) GetEmail() string {
	if u == nil {
		return ""
	}
	return u.Email
}

func (u *User) GetRecommendationsPlaylistID() *string {
	if u == nil {
		return nil
	}
	return u.RecommendationsPlaylistID
}

func (u *User) GetThumb() string {
	if u == nil {
		return ""
	}
	return u.Thumb
}

func (u *User) GetProtected() *Protected {
	if u == nil {
		return nil
	}
	return u.Protected
}

func (u *User) GetHome() *Home {
	if u == nil {
		return nil
	}
	return u.Home
}

func (u *User) GetAllowTuners() *AllowTuners {
	if u == nil {
		return nil
	}
	return u.AllowTuners
}

func (u *User) GetAllowSync() *AllowSync {
	if u == nil {
		return nil
	}
	return u.AllowSync
}

func (u *User) GetAllowCameraUpload() *AllowCameraUpload {
	if u == nil {
		return nil
	}
	return u.AllowCameraUpload
}

func (u *User) GetAllowChannels() *AllowChannels {
	if u == nil {
		return nil
	}
	return u.AllowChannels
}

func (u *User) GetAllowSubtitleAdmin() *AllowSubtitleAdmin {
	if u == nil {
		return nil
	}
	return u.AllowSubtitleAdmin
}

func (u *User) GetFilterAll() *string {
	if u == nil {
		return nil
	}
	return u.FilterAll
}

func (u *User) GetFilterMovies() *string {
	if u == nil {
		return nil
	}
	return u.FilterMovies
}

func (u *User) GetFilterMusic() *string {
	if u == nil {
		return nil
	}
	return u.FilterMusic
}

func (u *User) GetFilterPhotos() *string {
	if u == nil {
		return nil
	}
	return u.FilterPhotos
}

func (u *User) GetFilterTelevision() *string {
	if u == nil {
		return nil
	}
	return u.FilterTelevision
}

func (u *User) GetRestricted() *Restricted {
	if u == nil {
		return nil
	}
	return u.Restricted
}

func (u *User) GetServer() []Server {
	if u == nil {
		return []Server{}
	}
	return u.Server
}

// GetUsersMediaContainer - Container holding user and server details.
type GetUsersMediaContainer struct {
	// The friendly name of the Plex instance.
	FriendlyName string `json:"friendlyName"`
	Identifier   string `json:"identifier"`
	// Unique Machine identifier of the Plex server.
	MachineIdentifier string `json:"machineIdentifier"`
	// Total number of users.
	TotalSize int64 `json:"totalSize"`
	// Number of users in the current response.
	Size int64 `json:"size"`
	// List of users with access to the Plex server.
	User []User `json:"User"`
}

func (g *GetUsersMediaContainer) GetFriendlyName() string {
	if g == nil {
		return ""
	}
	return g.FriendlyName
}

func (g *GetUsersMediaContainer) GetIdentifier() string {
	if g == nil {
		return ""
	}
	return g.Identifier
}

func (g *GetUsersMediaContainer) GetMachineIdentifier() string {
	if g == nil {
		return ""
	}
	return g.MachineIdentifier
}

func (g *GetUsersMediaContainer) GetTotalSize() int64 {
	if g == nil {
		return 0
	}
	return g.TotalSize
}

func (g *GetUsersMediaContainer) GetSize() int64 {
	if g == nil {
		return 0
	}
	return g.Size
}

func (g *GetUsersMediaContainer) GetUser() []User {
	if g == nil {
		return []User{}
	}
	return g.User
}

// GetUsersResponseBody - Successful response with media container data in JSON
type GetUsersResponseBody struct {
	// Container holding user and server details.
	MediaContainer *GetUsersMediaContainer `json:"MediaContainer,omitempty"`
}

func (g *GetUsersResponseBody) GetMediaContainer() *GetUsersMediaContainer {
	if g == nil {
		return nil
	}
	return g.MediaContainer
}

type GetUsersResponse struct {
	// HTTP response content type for this operation
	ContentType string
	// HTTP response status code for this operation
	StatusCode int
	// Raw HTTP response; suitable for custom response parsing
	RawResponse *http.Response
	// Successful response with media container data in JSON
	Object *GetUsersResponseBody
}

func (g *GetUsersResponse) GetContentType() string {
	if g == nil {
		return ""
	}
	return g.ContentType
}

func (g *GetUsersResponse) GetStatusCode() int {
	if g == nil {
		return 0
	}
	return g.StatusCode
}

func (g *GetUsersResponse) GetRawResponse() *http.Response {
	if g == nil {
		return nil
	}
	return g.RawResponse
}

func (g *GetUsersResponse) GetObject() *GetUsersResponseBody {
	if g == nil {
		return nil
	}
	return g.Object
}
