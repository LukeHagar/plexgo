// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"github.com/LukeHagar/plexgo/internal/utils"
	"github.com/LukeHagar/plexgo/types"
	"net/http"
)

var GetWatchListServerList = []string{
	"https://discover.provider.plex.tv",
}

// Filter
type Filter string

const (
	FilterAll       Filter = "all"
	FilterAvailable Filter = "available"
	FilterReleased  Filter = "released"
)

func (e Filter) ToPointer() *Filter {
	return &e
}

// Libtype - The type of library to filter. Can be "movie" or "show", or all if not present.
type Libtype string

const (
	LibtypeMovie Libtype = "movie"
	LibtypeShow  Libtype = "show"
)

func (e Libtype) ToPointer() *Libtype {
	return &e
}

// IncludeCollections - include collections in the results
type IncludeCollections int64

const (
	IncludeCollectionsOne  IncludeCollections = 1
	IncludeCollectionsZero IncludeCollections = 0
)

func (e IncludeCollections) ToPointer() *IncludeCollections {
	return &e
}
func (e *IncludeCollections) UnmarshalJSON(data []byte) error {
	var v int64
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 1:
		fallthrough
	case 0:
		*e = IncludeCollections(v)
		return nil
	default:
		return fmt.Errorf("invalid value for IncludeCollections: %v", v)
	}
}

// IncludeExternalMedia - include external media in the results
type IncludeExternalMedia int64

const (
	IncludeExternalMediaOne  IncludeExternalMedia = 1
	IncludeExternalMediaZero IncludeExternalMedia = 0
)

func (e IncludeExternalMedia) ToPointer() *IncludeExternalMedia {
	return &e
}
func (e *IncludeExternalMedia) UnmarshalJSON(data []byte) error {
	var v int64
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 1:
		fallthrough
	case 0:
		*e = IncludeExternalMedia(v)
		return nil
	default:
		return fmt.Errorf("invalid value for IncludeExternalMedia: %v", v)
	}
}

type GetWatchListRequest struct {
	// Filter
	Filter Filter `pathParam:"style=simple,explode=false,name=filter"`
	// In the format "field:dir". Available fields are "watchlistedAt" (Added At),
	// "titleSort" (Title), "originallyAvailableAt" (Release Date), or "rating" (Critic Rating).
	// "dir" can be "asc" or "desc"
	//
	Sort *string `queryParam:"style=form,explode=true,name=sort"`
	// The type of library to filter. Can be "movie" or "show", or all if not present.
	//
	Libtype *Libtype `queryParam:"style=form,explode=true,name=libtype"`
	// The number of items to return. If not specified, all items will be returned.
	// If the number of items exceeds the limit, the response will be paginated.
	//
	Maxresults *int `queryParam:"style=form,explode=true,name=maxresults"`
	// include collections in the results
	//
	IncludeCollections *IncludeCollections `queryParam:"style=form,explode=true,name=includeCollections"`
	// include external media in the results
	//
	IncludeExternalMedia *IncludeExternalMedia `queryParam:"style=form,explode=true,name=includeExternalMedia"`
	// The index of the first item to return. If not specified, the first item will be returned.
	// If the number of items exceeds the limit, the response will be paginated.
	// By default this is 0
	//
	XPlexContainerStart *int `default:"0" queryParam:"style=form,explode=true,name=X-Plex-Container-Start"`
	// The number of items to return. If not specified, all items will be returned.
	// If the number of items exceeds the limit, the response will be paginated.
	// By default this is 50
	//
	XPlexContainerSize *int `default:"50" queryParam:"style=form,explode=true,name=X-Plex-Container-Size"`
	// An authentication token, obtained from plex.tv
	XPlexToken string `header:"style=simple,explode=false,name=X-Plex-Token"`
}

func (g GetWatchListRequest) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetWatchListRequest) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"filter", "X-Plex-Token"}); err != nil {
		return err
	}
	return nil
}

func (g *GetWatchListRequest) GetFilter() Filter {
	if g == nil {
		return Filter("")
	}
	return g.Filter
}

func (g *GetWatchListRequest) GetSort() *string {
	if g == nil {
		return nil
	}
	return g.Sort
}

func (g *GetWatchListRequest) GetLibtype() *Libtype {
	if g == nil {
		return nil
	}
	return g.Libtype
}

func (g *GetWatchListRequest) GetMaxresults() *int {
	if g == nil {
		return nil
	}
	return g.Maxresults
}

func (g *GetWatchListRequest) GetIncludeCollections() *IncludeCollections {
	if g == nil {
		return nil
	}
	return g.IncludeCollections
}

func (g *GetWatchListRequest) GetIncludeExternalMedia() *IncludeExternalMedia {
	if g == nil {
		return nil
	}
	return g.IncludeExternalMedia
}

func (g *GetWatchListRequest) GetXPlexContainerStart() *int {
	if g == nil {
		return nil
	}
	return g.XPlexContainerStart
}

func (g *GetWatchListRequest) GetXPlexContainerSize() *int {
	if g == nil {
		return nil
	}
	return g.XPlexContainerSize
}

func (g *GetWatchListRequest) GetXPlexToken() string {
	if g == nil {
		return ""
	}
	return g.XPlexToken
}

type Image struct {
	Alt  *string `json:"alt,omitempty"`
	Type *string `json:"type,omitempty"`
	URL  *string `json:"url,omitempty"`
}

func (i *Image) GetAlt() *string {
	if i == nil {
		return nil
	}
	return i.Alt
}

func (i *Image) GetType() *string {
	if i == nil {
		return nil
	}
	return i.Type
}

func (i *Image) GetURL() *string {
	if i == nil {
		return nil
	}
	return i.URL
}

type Metadata struct {
	Art                   *string     `json:"art,omitempty"`
	GUID                  *string     `json:"guid,omitempty"`
	Key                   *string     `json:"key,omitempty"`
	RatingKey             *string     `json:"ratingKey,omitempty"`
	Studio                *string     `json:"studio,omitempty"`
	Tagline               *string     `json:"tagline,omitempty"`
	Type                  *string     `json:"type,omitempty"`
	Thumb                 *string     `json:"thumb,omitempty"`
	AddedAt               *int        `json:"addedAt,omitempty"`
	Duration              *int        `json:"duration,omitempty"`
	PublicPagesURL        *string     `json:"publicPagesURL,omitempty"`
	Slug                  *string     `json:"slug,omitempty"`
	UserState             *bool       `json:"userState,omitempty"`
	Title                 *string     `json:"title,omitempty"`
	ContentRating         *string     `json:"contentRating,omitempty"`
	OriginallyAvailableAt *types.Date `json:"originallyAvailableAt,omitempty"`
	Year                  *int        `json:"year,omitempty"`
	Image                 []Image     `json:"Image,omitempty"`
	Banner                *string     `json:"banner,omitempty"`
	Rating                *float64    `json:"rating,omitempty"`
	ExpiresAt             *int        `json:"expiresAt,omitempty"`
	OriginalTitle         *string     `json:"originalTitle,omitempty"`
	AudienceRating        *float64    `json:"audienceRating,omitempty"`
	AudienceRatingImage   *string     `json:"audienceRatingImage,omitempty"`
	RatingImage           *string     `json:"ratingImage,omitempty"`
	ImdbRatingCount       *int        `json:"imdbRatingCount,omitempty"`
	Subtype               *string     `json:"subtype,omitempty"`
	Theme                 *string     `json:"theme,omitempty"`
	LeafCount             *int        `json:"leafCount,omitempty"`
	ChildCount            *int        `json:"childCount,omitempty"`
	IsContinuingSeries    *bool       `json:"isContinuingSeries,omitempty"`
	SkipChildren          *bool       `json:"skipChildren,omitempty"`
	AvailabilityID        *string     `json:"availabilityId,omitempty"`
	StreamingMediaID      *string     `json:"streamingMediaId,omitempty"`
	PlayableKey           *string     `json:"playableKey,omitempty"`
}

func (m Metadata) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *Metadata) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (m *Metadata) GetArt() *string {
	if m == nil {
		return nil
	}
	return m.Art
}

func (m *Metadata) GetGUID() *string {
	if m == nil {
		return nil
	}
	return m.GUID
}

func (m *Metadata) GetKey() *string {
	if m == nil {
		return nil
	}
	return m.Key
}

func (m *Metadata) GetRatingKey() *string {
	if m == nil {
		return nil
	}
	return m.RatingKey
}

func (m *Metadata) GetStudio() *string {
	if m == nil {
		return nil
	}
	return m.Studio
}

func (m *Metadata) GetTagline() *string {
	if m == nil {
		return nil
	}
	return m.Tagline
}

func (m *Metadata) GetType() *string {
	if m == nil {
		return nil
	}
	return m.Type
}

func (m *Metadata) GetThumb() *string {
	if m == nil {
		return nil
	}
	return m.Thumb
}

func (m *Metadata) GetAddedAt() *int {
	if m == nil {
		return nil
	}
	return m.AddedAt
}

func (m *Metadata) GetDuration() *int {
	if m == nil {
		return nil
	}
	return m.Duration
}

func (m *Metadata) GetPublicPagesURL() *string {
	if m == nil {
		return nil
	}
	return m.PublicPagesURL
}

func (m *Metadata) GetSlug() *string {
	if m == nil {
		return nil
	}
	return m.Slug
}

func (m *Metadata) GetUserState() *bool {
	if m == nil {
		return nil
	}
	return m.UserState
}

func (m *Metadata) GetTitle() *string {
	if m == nil {
		return nil
	}
	return m.Title
}

func (m *Metadata) GetContentRating() *string {
	if m == nil {
		return nil
	}
	return m.ContentRating
}

func (m *Metadata) GetOriginallyAvailableAt() *types.Date {
	if m == nil {
		return nil
	}
	return m.OriginallyAvailableAt
}

func (m *Metadata) GetYear() *int {
	if m == nil {
		return nil
	}
	return m.Year
}

func (m *Metadata) GetImage() []Image {
	if m == nil {
		return nil
	}
	return m.Image
}

func (m *Metadata) GetBanner() *string {
	if m == nil {
		return nil
	}
	return m.Banner
}

func (m *Metadata) GetRating() *float64 {
	if m == nil {
		return nil
	}
	return m.Rating
}

func (m *Metadata) GetExpiresAt() *int {
	if m == nil {
		return nil
	}
	return m.ExpiresAt
}

func (m *Metadata) GetOriginalTitle() *string {
	if m == nil {
		return nil
	}
	return m.OriginalTitle
}

func (m *Metadata) GetAudienceRating() *float64 {
	if m == nil {
		return nil
	}
	return m.AudienceRating
}

func (m *Metadata) GetAudienceRatingImage() *string {
	if m == nil {
		return nil
	}
	return m.AudienceRatingImage
}

func (m *Metadata) GetRatingImage() *string {
	if m == nil {
		return nil
	}
	return m.RatingImage
}

func (m *Metadata) GetImdbRatingCount() *int {
	if m == nil {
		return nil
	}
	return m.ImdbRatingCount
}

func (m *Metadata) GetSubtype() *string {
	if m == nil {
		return nil
	}
	return m.Subtype
}

func (m *Metadata) GetTheme() *string {
	if m == nil {
		return nil
	}
	return m.Theme
}

func (m *Metadata) GetLeafCount() *int {
	if m == nil {
		return nil
	}
	return m.LeafCount
}

func (m *Metadata) GetChildCount() *int {
	if m == nil {
		return nil
	}
	return m.ChildCount
}

func (m *Metadata) GetIsContinuingSeries() *bool {
	if m == nil {
		return nil
	}
	return m.IsContinuingSeries
}

func (m *Metadata) GetSkipChildren() *bool {
	if m == nil {
		return nil
	}
	return m.SkipChildren
}

func (m *Metadata) GetAvailabilityID() *string {
	if m == nil {
		return nil
	}
	return m.AvailabilityID
}

func (m *Metadata) GetStreamingMediaID() *string {
	if m == nil {
		return nil
	}
	return m.StreamingMediaID
}

func (m *Metadata) GetPlayableKey() *string {
	if m == nil {
		return nil
	}
	return m.PlayableKey
}

// GetWatchListResponseBody - Watchlist Data
type GetWatchListResponseBody struct {
	LibrarySectionID    *string    `json:"librarySectionID,omitempty"`
	LibrarySectionTitle *string    `json:"librarySectionTitle,omitempty"`
	Offset              *int       `json:"offset,omitempty"`
	TotalSize           *int       `json:"totalSize,omitempty"`
	Identifier          *string    `json:"identifier,omitempty"`
	Size                *int       `json:"size,omitempty"`
	Metadata            []Metadata `json:"Metadata,omitempty"`
}

func (g *GetWatchListResponseBody) GetLibrarySectionID() *string {
	if g == nil {
		return nil
	}
	return g.LibrarySectionID
}

func (g *GetWatchListResponseBody) GetLibrarySectionTitle() *string {
	if g == nil {
		return nil
	}
	return g.LibrarySectionTitle
}

func (g *GetWatchListResponseBody) GetOffset() *int {
	if g == nil {
		return nil
	}
	return g.Offset
}

func (g *GetWatchListResponseBody) GetTotalSize() *int {
	if g == nil {
		return nil
	}
	return g.TotalSize
}

func (g *GetWatchListResponseBody) GetIdentifier() *string {
	if g == nil {
		return nil
	}
	return g.Identifier
}

func (g *GetWatchListResponseBody) GetSize() *int {
	if g == nil {
		return nil
	}
	return g.Size
}

func (g *GetWatchListResponseBody) GetMetadata() []Metadata {
	if g == nil {
		return nil
	}
	return g.Metadata
}

type GetWatchListResponse struct {
	// HTTP response content type for this operation
	ContentType string
	// HTTP response status code for this operation
	StatusCode int
	// Raw HTTP response; suitable for custom response parsing
	RawResponse *http.Response
	// Watchlist Data
	Object *GetWatchListResponseBody
}

func (g *GetWatchListResponse) GetContentType() string {
	if g == nil {
		return ""
	}
	return g.ContentType
}

func (g *GetWatchListResponse) GetStatusCode() int {
	if g == nil {
		return 0
	}
	return g.StatusCode
}

func (g *GetWatchListResponse) GetRawResponse() *http.Response {
	if g == nil {
		return nil
	}
	return g.RawResponse
}

func (g *GetWatchListResponse) GetObject() *GetWatchListResponseBody {
	if g == nil {
		return nil
	}
	return g.Object
}
