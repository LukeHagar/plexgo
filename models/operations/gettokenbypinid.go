// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"github.com/LukeHagar/plexgo/internal/utils"
	"net/http"
	"time"
)

var GetTokenByPinIDServerList = []string{
	"https://plex.tv/api/v2",
}

type GetTokenByPinIDRequest struct {
	// The PinID to retrieve an access token for
	PinID int64 `pathParam:"style=simple,explode=false,name=pinID"`
	// An opaque identifier unique to the client (UUID, serial number, or other unique device ID)
	ClientID string `header:"style=simple,explode=false,name=X-Plex-Client-Identifier"`
	// The name of the client application. (Plex Web, Plex Media Server, etc.)
	ClientName *string `header:"style=simple,explode=false,name=X-Plex-Product"`
	// A relatively friendly name for the client device
	DeviceNickname *string `header:"style=simple,explode=false,name=X-Plex-Device"`
	// The version of the client application.
	ClientVersion *string `header:"style=simple,explode=false,name=X-Plex-Version"`
	// The platform of the client application.
	Platform *string `header:"style=simple,explode=false,name=X-Plex-Platform"`
}

func (g *GetTokenByPinIDRequest) GetPinID() int64 {
	if g == nil {
		return 0
	}
	return g.PinID
}

func (g *GetTokenByPinIDRequest) GetClientID() string {
	if g == nil {
		return ""
	}
	return g.ClientID
}

func (g *GetTokenByPinIDRequest) GetClientName() *string {
	if g == nil {
		return nil
	}
	return g.ClientName
}

func (g *GetTokenByPinIDRequest) GetDeviceNickname() *string {
	if g == nil {
		return nil
	}
	return g.DeviceNickname
}

func (g *GetTokenByPinIDRequest) GetClientVersion() *string {
	if g == nil {
		return nil
	}
	return g.ClientVersion
}

func (g *GetTokenByPinIDRequest) GetPlatform() *string {
	if g == nil {
		return nil
	}
	return g.Platform
}

// GetTokenByPinIDGeoData - Geo location data
type GetTokenByPinIDGeoData struct {
	// The ISO 3166-1 alpha-2 code of the country.
	Code string `json:"code"`
	// The continent code where the country is located.
	ContinentCode string `json:"continent_code"`
	// The official name of the country.
	Country string `json:"country"`
	// The name of the city.
	City string `json:"city"`
	// Indicates if the country is a member of the European Union.
	EuropeanUnionMember *bool `default:"false" json:"european_union_member"`
	// The time zone of the country.
	TimeZone string `json:"time_zone"`
	// The postal code of the location.
	PostalCode string `json:"postal_code"`
	// Indicates if the country has privacy restrictions.
	InPrivacyRestrictedCountry *bool `default:"false" json:"in_privacy_restricted_country"`
	// Indicates if the region has privacy restrictions.
	InPrivacyRestrictedRegion *bool `default:"false" json:"in_privacy_restricted_region"`
	// The name of the primary administrative subdivision.
	Subdivisions string `json:"subdivisions"`
	// The geographical coordinates (latitude, longitude) of the location.
	Coordinates string `json:"coordinates"`
}

func (g GetTokenByPinIDGeoData) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetTokenByPinIDGeoData) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"code", "continent_code", "country", "city", "time_zone", "postal_code", "subdivisions", "coordinates"}); err != nil {
		return err
	}
	return nil
}

func (g *GetTokenByPinIDGeoData) GetCode() string {
	if g == nil {
		return ""
	}
	return g.Code
}

func (g *GetTokenByPinIDGeoData) GetContinentCode() string {
	if g == nil {
		return ""
	}
	return g.ContinentCode
}

func (g *GetTokenByPinIDGeoData) GetCountry() string {
	if g == nil {
		return ""
	}
	return g.Country
}

func (g *GetTokenByPinIDGeoData) GetCity() string {
	if g == nil {
		return ""
	}
	return g.City
}

func (g *GetTokenByPinIDGeoData) GetEuropeanUnionMember() *bool {
	if g == nil {
		return nil
	}
	return g.EuropeanUnionMember
}

func (g *GetTokenByPinIDGeoData) GetTimeZone() string {
	if g == nil {
		return ""
	}
	return g.TimeZone
}

func (g *GetTokenByPinIDGeoData) GetPostalCode() string {
	if g == nil {
		return ""
	}
	return g.PostalCode
}

func (g *GetTokenByPinIDGeoData) GetInPrivacyRestrictedCountry() *bool {
	if g == nil {
		return nil
	}
	return g.InPrivacyRestrictedCountry
}

func (g *GetTokenByPinIDGeoData) GetInPrivacyRestrictedRegion() *bool {
	if g == nil {
		return nil
	}
	return g.InPrivacyRestrictedRegion
}

func (g *GetTokenByPinIDGeoData) GetSubdivisions() string {
	if g == nil {
		return ""
	}
	return g.Subdivisions
}

func (g *GetTokenByPinIDGeoData) GetCoordinates() string {
	if g == nil {
		return ""
	}
	return g.Coordinates
}

// GetTokenByPinIDAuthPinContainer - The Pin with a non-null authToken when it has been verified by the user
type GetTokenByPinIDAuthPinContainer struct {
	ID      int64  `json:"id"`
	Code    string `json:"code"`
	Product string `json:"product"`
	Trusted *bool  `default:"false" json:"trusted"`
	Qr      string `json:"qr"`
	// The X-Client-Identifier used in the request
	ClientIdentifier string `json:"clientIdentifier"`
	// Geo location data
	Location GetTokenByPinIDGeoData `json:"location"`
	// The number of seconds this pin expires, by default 900 seconds
	ExpiresIn       *int64    `default:"900" json:"expiresIn"`
	CreatedAt       time.Time `json:"createdAt"`
	ExpiresAt       time.Time `json:"expiresAt"`
	AuthToken       *string   `json:"authToken,omitempty"`
	NewRegistration any       `json:"newRegistration,omitempty"`
}

func (g GetTokenByPinIDAuthPinContainer) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetTokenByPinIDAuthPinContainer) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"id", "code", "product", "qr", "clientIdentifier", "location", "createdAt", "expiresAt"}); err != nil {
		return err
	}
	return nil
}

func (g *GetTokenByPinIDAuthPinContainer) GetID() int64 {
	if g == nil {
		return 0
	}
	return g.ID
}

func (g *GetTokenByPinIDAuthPinContainer) GetCode() string {
	if g == nil {
		return ""
	}
	return g.Code
}

func (g *GetTokenByPinIDAuthPinContainer) GetProduct() string {
	if g == nil {
		return ""
	}
	return g.Product
}

func (g *GetTokenByPinIDAuthPinContainer) GetTrusted() *bool {
	if g == nil {
		return nil
	}
	return g.Trusted
}

func (g *GetTokenByPinIDAuthPinContainer) GetQr() string {
	if g == nil {
		return ""
	}
	return g.Qr
}

func (g *GetTokenByPinIDAuthPinContainer) GetClientIdentifier() string {
	if g == nil {
		return ""
	}
	return g.ClientIdentifier
}

func (g *GetTokenByPinIDAuthPinContainer) GetLocation() GetTokenByPinIDGeoData {
	if g == nil {
		return GetTokenByPinIDGeoData{}
	}
	return g.Location
}

func (g *GetTokenByPinIDAuthPinContainer) GetExpiresIn() *int64 {
	if g == nil {
		return nil
	}
	return g.ExpiresIn
}

func (g *GetTokenByPinIDAuthPinContainer) GetCreatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.CreatedAt
}

func (g *GetTokenByPinIDAuthPinContainer) GetExpiresAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.ExpiresAt
}

func (g *GetTokenByPinIDAuthPinContainer) GetAuthToken() *string {
	if g == nil {
		return nil
	}
	return g.AuthToken
}

func (g *GetTokenByPinIDAuthPinContainer) GetNewRegistration() any {
	if g == nil {
		return nil
	}
	return g.NewRegistration
}

type GetTokenByPinIDResponse struct {
	// HTTP response content type for this operation
	ContentType string
	// HTTP response status code for this operation
	StatusCode int
	// Raw HTTP response; suitable for custom response parsing
	RawResponse *http.Response
	// The Pin with a non-null authToken when it has been verified by the user
	AuthPinContainer *GetTokenByPinIDAuthPinContainer
}

func (g *GetTokenByPinIDResponse) GetContentType() string {
	if g == nil {
		return ""
	}
	return g.ContentType
}

func (g *GetTokenByPinIDResponse) GetStatusCode() int {
	if g == nil {
		return 0
	}
	return g.StatusCode
}

func (g *GetTokenByPinIDResponse) GetRawResponse() *http.Response {
	if g == nil {
		return nil
	}
	return g.RawResponse
}

func (g *GetTokenByPinIDResponse) GetAuthPinContainer() *GetTokenByPinIDAuthPinContainer {
	if g == nil {
		return nil
	}
	return g.AuthPinContainer
}
