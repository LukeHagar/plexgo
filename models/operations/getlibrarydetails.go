// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"github.com/LukeHagar/plexgo/internal/utils"
	"github.com/LukeHagar/plexgo/models/components"
	"net/http"
)

type GetLibraryDetailsGlobals struct {
	// Indicates the client accepts the indicated media types
	Accepts *components.Accepts `default:"application/xml" header:"style=simple,explode=false,name=accepts"`
	// An opaque identifier unique to the client
	ClientIdentifier *string `header:"style=simple,explode=false,name=X-Plex-Client-Identifier"`
	// The name of the client product
	Product *string `header:"style=simple,explode=false,name=X-Plex-Product"`
	// The version of the client application
	Version *string `header:"style=simple,explode=false,name=X-Plex-Version"`
	// The platform of the client
	Platform *string `header:"style=simple,explode=false,name=X-Plex-Platform"`
	// The version of the platform
	PlatformVersion *string `header:"style=simple,explode=false,name=X-Plex-Platform-Version"`
	// A relatively friendly name for the client device
	Device *string `header:"style=simple,explode=false,name=X-Plex-Device"`
	// A potentially less friendly identifier for the device model
	Model *string `header:"style=simple,explode=false,name=X-Plex-Model"`
	// The device vendor
	DeviceVendor *string `header:"style=simple,explode=false,name=X-Plex-Device-Vendor"`
	// A friendly name for the client
	DeviceName *string `header:"style=simple,explode=false,name=X-Plex-Device-Name"`
	// The marketplace on which the client application is distributed
	Marketplace *string `header:"style=simple,explode=false,name=X-Plex-Marketplace"`
}

func (g GetLibraryDetailsGlobals) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetLibraryDetailsGlobals) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (g *GetLibraryDetailsGlobals) GetAccepts() *components.Accepts {
	if g == nil {
		return nil
	}
	return g.Accepts
}

func (g *GetLibraryDetailsGlobals) GetClientIdentifier() *string {
	if g == nil {
		return nil
	}
	return g.ClientIdentifier
}

func (g *GetLibraryDetailsGlobals) GetProduct() *string {
	if g == nil {
		return nil
	}
	return g.Product
}

func (g *GetLibraryDetailsGlobals) GetVersion() *string {
	if g == nil {
		return nil
	}
	return g.Version
}

func (g *GetLibraryDetailsGlobals) GetPlatform() *string {
	if g == nil {
		return nil
	}
	return g.Platform
}

func (g *GetLibraryDetailsGlobals) GetPlatformVersion() *string {
	if g == nil {
		return nil
	}
	return g.PlatformVersion
}

func (g *GetLibraryDetailsGlobals) GetDevice() *string {
	if g == nil {
		return nil
	}
	return g.Device
}

func (g *GetLibraryDetailsGlobals) GetModel() *string {
	if g == nil {
		return nil
	}
	return g.Model
}

func (g *GetLibraryDetailsGlobals) GetDeviceVendor() *string {
	if g == nil {
		return nil
	}
	return g.DeviceVendor
}

func (g *GetLibraryDetailsGlobals) GetDeviceName() *string {
	if g == nil {
		return nil
	}
	return g.DeviceName
}

func (g *GetLibraryDetailsGlobals) GetMarketplace() *string {
	if g == nil {
		return nil
	}
	return g.Marketplace
}

type GetLibraryDetailsRequest struct {
	// Indicates the client accepts the indicated media types
	Accepts *components.Accepts `default:"application/xml" header:"style=simple,explode=false,name=accepts"`
	// An opaque identifier unique to the client
	ClientIdentifier *string `header:"style=simple,explode=false,name=X-Plex-Client-Identifier"`
	// The name of the client product
	Product *string `header:"style=simple,explode=false,name=X-Plex-Product"`
	// The version of the client application
	Version *string `header:"style=simple,explode=false,name=X-Plex-Version"`
	// The platform of the client
	Platform *string `header:"style=simple,explode=false,name=X-Plex-Platform"`
	// The version of the platform
	PlatformVersion *string `header:"style=simple,explode=false,name=X-Plex-Platform-Version"`
	// A relatively friendly name for the client device
	Device *string `header:"style=simple,explode=false,name=X-Plex-Device"`
	// A potentially less friendly identifier for the device model
	Model *string `header:"style=simple,explode=false,name=X-Plex-Model"`
	// The device vendor
	DeviceVendor *string `header:"style=simple,explode=false,name=X-Plex-Device-Vendor"`
	// A friendly name for the client
	DeviceName *string `header:"style=simple,explode=false,name=X-Plex-Device-Name"`
	// The marketplace on which the client application is distributed
	Marketplace *string `header:"style=simple,explode=false,name=X-Plex-Marketplace"`
	// The section identifier
	SectionID string `pathParam:"style=simple,explode=false,name=sectionId"`
	// Whether or not to include details for a section (types, filters, and sorts). Only exists for backwards compatibility, media providers other than the server libraries have it on always.
	IncludeDetails *components.BoolInt `queryParam:"style=form,explode=true,name=includeDetails"`
}

func (g GetLibraryDetailsRequest) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetLibraryDetailsRequest) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"sectionId"}); err != nil {
		return err
	}
	return nil
}

func (g *GetLibraryDetailsRequest) GetAccepts() *components.Accepts {
	if g == nil {
		return nil
	}
	return g.Accepts
}

func (g *GetLibraryDetailsRequest) GetClientIdentifier() *string {
	if g == nil {
		return nil
	}
	return g.ClientIdentifier
}

func (g *GetLibraryDetailsRequest) GetProduct() *string {
	if g == nil {
		return nil
	}
	return g.Product
}

func (g *GetLibraryDetailsRequest) GetVersion() *string {
	if g == nil {
		return nil
	}
	return g.Version
}

func (g *GetLibraryDetailsRequest) GetPlatform() *string {
	if g == nil {
		return nil
	}
	return g.Platform
}

func (g *GetLibraryDetailsRequest) GetPlatformVersion() *string {
	if g == nil {
		return nil
	}
	return g.PlatformVersion
}

func (g *GetLibraryDetailsRequest) GetDevice() *string {
	if g == nil {
		return nil
	}
	return g.Device
}

func (g *GetLibraryDetailsRequest) GetModel() *string {
	if g == nil {
		return nil
	}
	return g.Model
}

func (g *GetLibraryDetailsRequest) GetDeviceVendor() *string {
	if g == nil {
		return nil
	}
	return g.DeviceVendor
}

func (g *GetLibraryDetailsRequest) GetDeviceName() *string {
	if g == nil {
		return nil
	}
	return g.DeviceName
}

func (g *GetLibraryDetailsRequest) GetMarketplace() *string {
	if g == nil {
		return nil
	}
	return g.Marketplace
}

func (g *GetLibraryDetailsRequest) GetSectionID() string {
	if g == nil {
		return ""
	}
	return g.SectionID
}

func (g *GetLibraryDetailsRequest) GetIncludeDetails() *components.BoolInt {
	if g == nil {
		return nil
	}
	return g.IncludeDetails
}

type GetLibraryDetailsMediaContainer struct {
	// The flavors of directory found here:
	//   - Primary: (e.g. all, On Deck) These are still used in some clients to provide "shortcuts" to subsets of media. However, with the exception of On Deck, all of them can be created by media queries, and the desire is to allow these to be customized by users.
	//   - Secondary: These are marked with `"secondary": true` and were used by old clients to provide nested menus allowing for primative (but structured) navigation.
	//   - Special: There is a By Folder entry which allows browsing the media by the underlying filesystem structure, and there's a completely obsolete entry marked `"search": true` which used to be used to allow clients to build search dialogs on the fly.
	Content          *string               `json:"content,omitempty"`
	AllowSync        *bool                 `json:"allowSync,omitempty"`
	Art              *string               `json:"art,omitempty"`
	Directory        []components.Metadata `json:"Directory,omitempty"`
	Identifier       *string               `json:"identifier,omitempty"`
	LibrarySectionID *int64                `json:"librarySectionID,omitempty"`
	MediaTagPrefix   *string               `json:"mediaTagPrefix,omitempty"`
	MediaTagVersion  *int64                `json:"mediaTagVersion,omitempty"`
	Size             *int64                `json:"size,omitempty"`
	SortAsc          *bool                 `json:"sortAsc,omitempty"`
	Thumb            *string               `json:"thumb,omitempty"`
	Title1           *string               `json:"title1,omitempty"`
	ViewGroup        *string               `json:"viewGroup,omitempty"`
	ViewMode         *int64                `json:"viewMode,omitempty"`
}

func (g *GetLibraryDetailsMediaContainer) GetContent() *string {
	if g == nil {
		return nil
	}
	return g.Content
}

func (g *GetLibraryDetailsMediaContainer) GetAllowSync() *bool {
	if g == nil {
		return nil
	}
	return g.AllowSync
}

func (g *GetLibraryDetailsMediaContainer) GetArt() *string {
	if g == nil {
		return nil
	}
	return g.Art
}

func (g *GetLibraryDetailsMediaContainer) GetDirectory() []components.Metadata {
	if g == nil {
		return nil
	}
	return g.Directory
}

func (g *GetLibraryDetailsMediaContainer) GetIdentifier() *string {
	if g == nil {
		return nil
	}
	return g.Identifier
}

func (g *GetLibraryDetailsMediaContainer) GetLibrarySectionID() *int64 {
	if g == nil {
		return nil
	}
	return g.LibrarySectionID
}

func (g *GetLibraryDetailsMediaContainer) GetMediaTagPrefix() *string {
	if g == nil {
		return nil
	}
	return g.MediaTagPrefix
}

func (g *GetLibraryDetailsMediaContainer) GetMediaTagVersion() *int64 {
	if g == nil {
		return nil
	}
	return g.MediaTagVersion
}

func (g *GetLibraryDetailsMediaContainer) GetSize() *int64 {
	if g == nil {
		return nil
	}
	return g.Size
}

func (g *GetLibraryDetailsMediaContainer) GetSortAsc() *bool {
	if g == nil {
		return nil
	}
	return g.SortAsc
}

func (g *GetLibraryDetailsMediaContainer) GetThumb() *string {
	if g == nil {
		return nil
	}
	return g.Thumb
}

func (g *GetLibraryDetailsMediaContainer) GetTitle1() *string {
	if g == nil {
		return nil
	}
	return g.Title1
}

func (g *GetLibraryDetailsMediaContainer) GetViewGroup() *string {
	if g == nil {
		return nil
	}
	return g.ViewGroup
}

func (g *GetLibraryDetailsMediaContainer) GetViewMode() *int64 {
	if g == nil {
		return nil
	}
	return g.ViewMode
}

// GetLibraryDetailsResponseBody - OK
type GetLibraryDetailsResponseBody struct {
	MediaContainer *GetLibraryDetailsMediaContainer `json:"MediaContainer,omitempty"`
}

func (g *GetLibraryDetailsResponseBody) GetMediaContainer() *GetLibraryDetailsMediaContainer {
	if g == nil {
		return nil
	}
	return g.MediaContainer
}

type GetLibraryDetailsResponse struct {
	// HTTP response content type for this operation
	ContentType string
	// HTTP response status code for this operation
	StatusCode int
	// Raw HTTP response; suitable for custom response parsing
	RawResponse *http.Response
	// OK
	Object *GetLibraryDetailsResponseBody
}

func (g *GetLibraryDetailsResponse) GetContentType() string {
	if g == nil {
		return ""
	}
	return g.ContentType
}

func (g *GetLibraryDetailsResponse) GetStatusCode() int {
	if g == nil {
		return 0
	}
	return g.StatusCode
}

func (g *GetLibraryDetailsResponse) GetRawResponse() *http.Response {
	if g == nil {
		return nil
	}
	return g.RawResponse
}

func (g *GetLibraryDetailsResponse) GetObject() *GetLibraryDetailsResponseBody {
	if g == nil {
		return nil
	}
	return g.Object
}
