// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"github.com/LukeHagar/plexgo/internal/utils"
	"github.com/LukeHagar/plexgo/models/components"
	"net/http"
)

type AddDownloadQueueItemsGlobals struct {
	// Indicates the client accepts the indicated media types
	Accepts *components.Accepts `default:"application/xml" header:"style=simple,explode=false,name=accepts"`
	// An opaque identifier unique to the client
	ClientIdentifier *string `header:"style=simple,explode=false,name=X-Plex-Client-Identifier"`
	// The name of the client product
	Product *string `header:"style=simple,explode=false,name=X-Plex-Product"`
	// The version of the client application
	Version *string `header:"style=simple,explode=false,name=X-Plex-Version"`
	// The platform of the client
	Platform *string `header:"style=simple,explode=false,name=X-Plex-Platform"`
	// The version of the platform
	PlatformVersion *string `header:"style=simple,explode=false,name=X-Plex-Platform-Version"`
	// A relatively friendly name for the client device
	Device *string `header:"style=simple,explode=false,name=X-Plex-Device"`
	// A potentially less friendly identifier for the device model
	Model *string `header:"style=simple,explode=false,name=X-Plex-Model"`
	// The device vendor
	DeviceVendor *string `header:"style=simple,explode=false,name=X-Plex-Device-Vendor"`
	// A friendly name for the client
	DeviceName *string `header:"style=simple,explode=false,name=X-Plex-Device-Name"`
	// The marketplace on which the client application is distributed
	Marketplace *string `header:"style=simple,explode=false,name=X-Plex-Marketplace"`
}

func (a AddDownloadQueueItemsGlobals) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AddDownloadQueueItemsGlobals) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *AddDownloadQueueItemsGlobals) GetAccepts() *components.Accepts {
	if a == nil {
		return nil
	}
	return a.Accepts
}

func (a *AddDownloadQueueItemsGlobals) GetClientIdentifier() *string {
	if a == nil {
		return nil
	}
	return a.ClientIdentifier
}

func (a *AddDownloadQueueItemsGlobals) GetProduct() *string {
	if a == nil {
		return nil
	}
	return a.Product
}

func (a *AddDownloadQueueItemsGlobals) GetVersion() *string {
	if a == nil {
		return nil
	}
	return a.Version
}

func (a *AddDownloadQueueItemsGlobals) GetPlatform() *string {
	if a == nil {
		return nil
	}
	return a.Platform
}

func (a *AddDownloadQueueItemsGlobals) GetPlatformVersion() *string {
	if a == nil {
		return nil
	}
	return a.PlatformVersion
}

func (a *AddDownloadQueueItemsGlobals) GetDevice() *string {
	if a == nil {
		return nil
	}
	return a.Device
}

func (a *AddDownloadQueueItemsGlobals) GetModel() *string {
	if a == nil {
		return nil
	}
	return a.Model
}

func (a *AddDownloadQueueItemsGlobals) GetDeviceVendor() *string {
	if a == nil {
		return nil
	}
	return a.DeviceVendor
}

func (a *AddDownloadQueueItemsGlobals) GetDeviceName() *string {
	if a == nil {
		return nil
	}
	return a.DeviceName
}

func (a *AddDownloadQueueItemsGlobals) GetMarketplace() *string {
	if a == nil {
		return nil
	}
	return a.Marketplace
}

type AddDownloadQueueItemsRequest struct {
	// Indicates the client accepts the indicated media types
	Accepts *components.Accepts `default:"application/xml" header:"style=simple,explode=false,name=accepts"`
	// An opaque identifier unique to the client
	ClientIdentifier *string `header:"style=simple,explode=false,name=X-Plex-Client-Identifier"`
	// The name of the client product
	Product *string `header:"style=simple,explode=false,name=X-Plex-Product"`
	// The version of the client application
	Version *string `header:"style=simple,explode=false,name=X-Plex-Version"`
	// The platform of the client
	Platform *string `header:"style=simple,explode=false,name=X-Plex-Platform"`
	// The version of the platform
	PlatformVersion *string `header:"style=simple,explode=false,name=X-Plex-Platform-Version"`
	// A relatively friendly name for the client device
	Device *string `header:"style=simple,explode=false,name=X-Plex-Device"`
	// A potentially less friendly identifier for the device model
	Model *string `header:"style=simple,explode=false,name=X-Plex-Model"`
	// The device vendor
	DeviceVendor *string `header:"style=simple,explode=false,name=X-Plex-Device-Vendor"`
	// A friendly name for the client
	DeviceName *string `header:"style=simple,explode=false,name=X-Plex-Device-Name"`
	// The marketplace on which the client application is distributed
	Marketplace *string `header:"style=simple,explode=false,name=X-Plex-Marketplace"`
	// The queue id
	QueueID int64 `pathParam:"style=simple,explode=false,name=queueId"`
	// Keys to add
	Keys []string `queryParam:"style=form,explode=false,name=keys"`
	// Indicates how incompatible advanced subtitles (such as ass/ssa) should be included: * 'burn' - Burn incompatible advanced text subtitles into the video stream * 'text' - Transcode incompatible advanced text subtitles to a compatible text format, even if some markup is lost
	//
	AdvancedSubtitles *components.AdvancedSubtitles `queryParam:"style=form,explode=true,name=advancedSubtitles"`
	// Percentage of original audio loudness to use when transcoding (100 is equivalent to original volume, 50 is half, 200 is double, etc)
	AudioBoost *int64 `queryParam:"style=form,explode=true,name=audioBoost"`
	// Target video number of audio channels.
	AudioChannelCount *int64 `queryParam:"style=form,explode=true,name=audioChannelCount"`
	// Indicates the client supports ABR.
	AutoAdjustQuality *components.BoolInt `queryParam:"style=form,explode=true,name=autoAdjustQuality"`
	// Indicates if the server should adjust subtitles based on Voice Activity Data.
	AutoAdjustSubtitle *components.BoolInt `queryParam:"style=form,explode=true,name=autoAdjustSubtitle"`
	// Indicates the client supports direct playing the indicated content.
	DirectPlay *components.BoolInt `queryParam:"style=form,explode=true,name=directPlay"`
	// Indicates the client supports direct streaming the video of the indicated content.
	DirectStream *components.BoolInt `queryParam:"style=form,explode=true,name=directStream"`
	// Indicates the client supports direct streaming the audio of the indicated content.
	DirectStreamAudio *components.BoolInt `queryParam:"style=form,explode=true,name=directStreamAudio"`
	// Indicates if resolution should be adjusted for orientation.
	DisableResolutionRotation *components.BoolInt `queryParam:"style=form,explode=true,name=disableResolutionRotation"`
	// Ignore client profiles when determining if direct play is possible. Only has an effect when directPlay=1 and both mediaIndex and partIndex are specified and neither are -1
	HasMDE *components.BoolInt `queryParam:"style=form,explode=true,name=hasMDE"`
	// Network type of the client, can be used to help determine target bitrate.
	Location *components.Location `queryParam:"style=form,explode=true,name=location"`
	// Buffer size used in playback (in KB). Clients should specify a lower bound if not known exactly. This value could make the difference between transcoding and direct play on bandwidth constrained networks.
	MediaBufferSize *int64 `queryParam:"style=form,explode=true,name=mediaBufferSize"`
	// Index of the media to transcode. -1 or not specified indicates let the server choose.
	MediaIndex *int64 `queryParam:"style=form,explode=true,name=mediaIndex"`
	// Target bitrate for audio only files (in kbps, used to transcode).
	MusicBitrate *int64 `queryParam:"style=form,explode=true,name=musicBitrate"`
	// Offset from the start of the media (in seconds).
	Offset *float64 `queryParam:"style=form,explode=true,name=offset"`
	// Index of the part to transcode. -1 or not specified indicates the server should join parts together in a transcode
	PartIndex *int64 `queryParam:"style=form,explode=true,name=partIndex"`
	// Internal PMS path of the media to transcode.
	Path *string `queryParam:"style=form,explode=true,name=path"`
	// Maximum bitrate (in kbps) to use in ABR.
	PeakBitrate *int64 `queryParam:"style=form,explode=true,name=peakBitrate"`
	// Target photo resolution.
	PhotoResolution *string `queryParam:"style=form,explode=true,name=photoResolution"`
	// Indicates the network streaming protocol to be used for the transcode session: * 'http' - include the file in the http response such as MKV streaming * 'hls' - hls stream (RFC 8216) * 'dash' - dash stream (ISO/IEC 23009-1:2022)
	//
	Protocol *components.Protocol `queryParam:"style=form,explode=true,name=protocol"`
	// Number of seconds to include in each transcoded segment
	SecondsPerSegment *int64 `queryParam:"style=form,explode=true,name=secondsPerSegment"`
	// Percentage of original subtitle size to use when burning subtitles (100 is equivalent to original size, 50 is half, ect)
	SubtitleSize *int64 `queryParam:"style=form,explode=true,name=subtitleSize"`
	// Indicates how subtitles should be included: * 'auto' - Compute the appropriate subtitle setting automatically * 'burn' - Burn the selected subtitle; auto if no selected subtitle * 'none' - Ignore all subtitle streams * 'sidecar' - The selected subtitle should be provided as a sidecar * 'embedded' - The selected subtitle should be provided as an embedded stream * 'segmented' - The selected subtitle should be provided as a segmented stream
	//
	Subtitles *components.Subtitles `queryParam:"style=form,explode=true,name=subtitles"`
	// Target video bitrate (in kbps).
	VideoBitrate *int64 `queryParam:"style=form,explode=true,name=videoBitrate"`
	// Target photo quality.
	VideoQuality *int64 `queryParam:"style=form,explode=true,name=videoQuality"`
	// Target maximum video resolution.
	VideoResolution *string `queryParam:"style=form,explode=true,name=videoResolution"`
}

func (a AddDownloadQueueItemsRequest) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AddDownloadQueueItemsRequest) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"queueId", "keys"}); err != nil {
		return err
	}
	return nil
}

func (a *AddDownloadQueueItemsRequest) GetAccepts() *components.Accepts {
	if a == nil {
		return nil
	}
	return a.Accepts
}

func (a *AddDownloadQueueItemsRequest) GetClientIdentifier() *string {
	if a == nil {
		return nil
	}
	return a.ClientIdentifier
}

func (a *AddDownloadQueueItemsRequest) GetProduct() *string {
	if a == nil {
		return nil
	}
	return a.Product
}

func (a *AddDownloadQueueItemsRequest) GetVersion() *string {
	if a == nil {
		return nil
	}
	return a.Version
}

func (a *AddDownloadQueueItemsRequest) GetPlatform() *string {
	if a == nil {
		return nil
	}
	return a.Platform
}

func (a *AddDownloadQueueItemsRequest) GetPlatformVersion() *string {
	if a == nil {
		return nil
	}
	return a.PlatformVersion
}

func (a *AddDownloadQueueItemsRequest) GetDevice() *string {
	if a == nil {
		return nil
	}
	return a.Device
}

func (a *AddDownloadQueueItemsRequest) GetModel() *string {
	if a == nil {
		return nil
	}
	return a.Model
}

func (a *AddDownloadQueueItemsRequest) GetDeviceVendor() *string {
	if a == nil {
		return nil
	}
	return a.DeviceVendor
}

func (a *AddDownloadQueueItemsRequest) GetDeviceName() *string {
	if a == nil {
		return nil
	}
	return a.DeviceName
}

func (a *AddDownloadQueueItemsRequest) GetMarketplace() *string {
	if a == nil {
		return nil
	}
	return a.Marketplace
}

func (a *AddDownloadQueueItemsRequest) GetQueueID() int64 {
	if a == nil {
		return 0
	}
	return a.QueueID
}

func (a *AddDownloadQueueItemsRequest) GetKeys() []string {
	if a == nil {
		return []string{}
	}
	return a.Keys
}

func (a *AddDownloadQueueItemsRequest) GetAdvancedSubtitles() *components.AdvancedSubtitles {
	if a == nil {
		return nil
	}
	return a.AdvancedSubtitles
}

func (a *AddDownloadQueueItemsRequest) GetAudioBoost() *int64 {
	if a == nil {
		return nil
	}
	return a.AudioBoost
}

func (a *AddDownloadQueueItemsRequest) GetAudioChannelCount() *int64 {
	if a == nil {
		return nil
	}
	return a.AudioChannelCount
}

func (a *AddDownloadQueueItemsRequest) GetAutoAdjustQuality() *components.BoolInt {
	if a == nil {
		return nil
	}
	return a.AutoAdjustQuality
}

func (a *AddDownloadQueueItemsRequest) GetAutoAdjustSubtitle() *components.BoolInt {
	if a == nil {
		return nil
	}
	return a.AutoAdjustSubtitle
}

func (a *AddDownloadQueueItemsRequest) GetDirectPlay() *components.BoolInt {
	if a == nil {
		return nil
	}
	return a.DirectPlay
}

func (a *AddDownloadQueueItemsRequest) GetDirectStream() *components.BoolInt {
	if a == nil {
		return nil
	}
	return a.DirectStream
}

func (a *AddDownloadQueueItemsRequest) GetDirectStreamAudio() *components.BoolInt {
	if a == nil {
		return nil
	}
	return a.DirectStreamAudio
}

func (a *AddDownloadQueueItemsRequest) GetDisableResolutionRotation() *components.BoolInt {
	if a == nil {
		return nil
	}
	return a.DisableResolutionRotation
}

func (a *AddDownloadQueueItemsRequest) GetHasMDE() *components.BoolInt {
	if a == nil {
		return nil
	}
	return a.HasMDE
}

func (a *AddDownloadQueueItemsRequest) GetLocation() *components.Location {
	if a == nil {
		return nil
	}
	return a.Location
}

func (a *AddDownloadQueueItemsRequest) GetMediaBufferSize() *int64 {
	if a == nil {
		return nil
	}
	return a.MediaBufferSize
}

func (a *AddDownloadQueueItemsRequest) GetMediaIndex() *int64 {
	if a == nil {
		return nil
	}
	return a.MediaIndex
}

func (a *AddDownloadQueueItemsRequest) GetMusicBitrate() *int64 {
	if a == nil {
		return nil
	}
	return a.MusicBitrate
}

func (a *AddDownloadQueueItemsRequest) GetOffset() *float64 {
	if a == nil {
		return nil
	}
	return a.Offset
}

func (a *AddDownloadQueueItemsRequest) GetPartIndex() *int64 {
	if a == nil {
		return nil
	}
	return a.PartIndex
}

func (a *AddDownloadQueueItemsRequest) GetPath() *string {
	if a == nil {
		return nil
	}
	return a.Path
}

func (a *AddDownloadQueueItemsRequest) GetPeakBitrate() *int64 {
	if a == nil {
		return nil
	}
	return a.PeakBitrate
}

func (a *AddDownloadQueueItemsRequest) GetPhotoResolution() *string {
	if a == nil {
		return nil
	}
	return a.PhotoResolution
}

func (a *AddDownloadQueueItemsRequest) GetProtocol() *components.Protocol {
	if a == nil {
		return nil
	}
	return a.Protocol
}

func (a *AddDownloadQueueItemsRequest) GetSecondsPerSegment() *int64 {
	if a == nil {
		return nil
	}
	return a.SecondsPerSegment
}

func (a *AddDownloadQueueItemsRequest) GetSubtitleSize() *int64 {
	if a == nil {
		return nil
	}
	return a.SubtitleSize
}

func (a *AddDownloadQueueItemsRequest) GetSubtitles() *components.Subtitles {
	if a == nil {
		return nil
	}
	return a.Subtitles
}

func (a *AddDownloadQueueItemsRequest) GetVideoBitrate() *int64 {
	if a == nil {
		return nil
	}
	return a.VideoBitrate
}

func (a *AddDownloadQueueItemsRequest) GetVideoQuality() *int64 {
	if a == nil {
		return nil
	}
	return a.VideoQuality
}

func (a *AddDownloadQueueItemsRequest) GetVideoResolution() *string {
	if a == nil {
		return nil
	}
	return a.VideoResolution
}

type AddedQueueItems struct {
	// The queue item id that was added or the existing one if an item already exists in this queue with the same parameters
	ID *int64 `json:"id,omitempty"`
	// The key added to the queue
	Key *string `json:"key,omitempty"`
}

func (a *AddedQueueItems) GetID() *int64 {
	if a == nil {
		return nil
	}
	return a.ID
}

func (a *AddedQueueItems) GetKey() *string {
	if a == nil {
		return nil
	}
	return a.Key
}

// AddDownloadQueueItemsMediaContainer - `MediaContainer` is the root element of most Plex API responses. It serves as a generic container for various types of content (Metadata, Hubs, Directories, etc.) and includes pagination information (offset, size, totalSize) when applicable.
// Common attributes: - identifier: Unique identifier for this container - size: Number of items in this response page - totalSize: Total number of items available (for pagination) - offset: Starting index of this page (for pagination)
// The container often "hoists" common attributes from its children. For example, if all tracks in a container share the same album title, the `parentTitle` attribute may appear on the MediaContainer rather than being repeated on each track.
type AddDownloadQueueItemsMediaContainer struct {
	Identifier *string `json:"identifier,omitempty"`
	// The offset of where this container page starts among the total objects available. Also provided in the `X-Plex-Container-Start` header.
	//
	Offset *int64 `json:"offset,omitempty"`
	Size   *int64 `json:"size,omitempty"`
	// The total size of objects available. Also provided in the `X-Plex-Container-Total-Size` header.
	//
	TotalSize       *int64            `json:"totalSize,omitempty"`
	AddedQueueItems []AddedQueueItems `json:"AddedQueueItems,omitempty"`
}

func (a *AddDownloadQueueItemsMediaContainer) GetIdentifier() *string {
	if a == nil {
		return nil
	}
	return a.Identifier
}

func (a *AddDownloadQueueItemsMediaContainer) GetOffset() *int64 {
	if a == nil {
		return nil
	}
	return a.Offset
}

func (a *AddDownloadQueueItemsMediaContainer) GetSize() *int64 {
	if a == nil {
		return nil
	}
	return a.Size
}

func (a *AddDownloadQueueItemsMediaContainer) GetTotalSize() *int64 {
	if a == nil {
		return nil
	}
	return a.TotalSize
}

func (a *AddDownloadQueueItemsMediaContainer) GetAddedQueueItems() []AddedQueueItems {
	if a == nil {
		return nil
	}
	return a.AddedQueueItems
}

// AddDownloadQueueItemsResponseBody - OK
type AddDownloadQueueItemsResponseBody struct {
	MediaContainer *AddDownloadQueueItemsMediaContainer `json:"MediaContainer,omitempty"`
}

func (a *AddDownloadQueueItemsResponseBody) GetMediaContainer() *AddDownloadQueueItemsMediaContainer {
	if a == nil {
		return nil
	}
	return a.MediaContainer
}

type AddDownloadQueueItemsResponse struct {
	// HTTP response content type for this operation
	ContentType string
	// HTTP response status code for this operation
	StatusCode int
	// Raw HTTP response; suitable for custom response parsing
	RawResponse *http.Response
	// OK
	Object *AddDownloadQueueItemsResponseBody
}

func (a *AddDownloadQueueItemsResponse) GetContentType() string {
	if a == nil {
		return ""
	}
	return a.ContentType
}

func (a *AddDownloadQueueItemsResponse) GetStatusCode() int {
	if a == nil {
		return 0
	}
	return a.StatusCode
}

func (a *AddDownloadQueueItemsResponse) GetRawResponse() *http.Response {
	if a == nil {
		return nil
	}
	return a.RawResponse
}

func (a *AddDownloadQueueItemsResponse) GetObject() *AddDownloadQueueItemsResponseBody {
	if a == nil {
		return nil
	}
	return a.Object
}
