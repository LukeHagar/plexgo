// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"github.com/LukeHagar/plexgo/internal/utils"
	"github.com/LukeHagar/plexgo/models/components"
	"net/http"
)

type MakeDecisionGlobals struct {
	// Indicates the client accepts the indicated media types
	Accepts *components.Accepts `default:"application/xml" header:"style=simple,explode=false,name=accepts"`
	// An opaque identifier unique to the client
	ClientIdentifier *string `header:"style=simple,explode=false,name=X-Plex-Client-Identifier"`
	// The name of the client product
	Product *string `header:"style=simple,explode=false,name=X-Plex-Product"`
	// The version of the client application
	Version *string `header:"style=simple,explode=false,name=X-Plex-Version"`
	// The platform of the client
	Platform *string `header:"style=simple,explode=false,name=X-Plex-Platform"`
	// The version of the platform
	PlatformVersion *string `header:"style=simple,explode=false,name=X-Plex-Platform-Version"`
	// A relatively friendly name for the client device
	Device *string `header:"style=simple,explode=false,name=X-Plex-Device"`
	// A potentially less friendly identifier for the device model
	Model *string `header:"style=simple,explode=false,name=X-Plex-Model"`
	// The device vendor
	DeviceVendor *string `header:"style=simple,explode=false,name=X-Plex-Device-Vendor"`
	// A friendly name for the client
	DeviceName *string `header:"style=simple,explode=false,name=X-Plex-Device-Name"`
	// The marketplace on which the client application is distributed
	Marketplace *string `header:"style=simple,explode=false,name=X-Plex-Marketplace"`
}

func (m MakeDecisionGlobals) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MakeDecisionGlobals) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (m *MakeDecisionGlobals) GetAccepts() *components.Accepts {
	if m == nil {
		return nil
	}
	return m.Accepts
}

func (m *MakeDecisionGlobals) GetClientIdentifier() *string {
	if m == nil {
		return nil
	}
	return m.ClientIdentifier
}

func (m *MakeDecisionGlobals) GetProduct() *string {
	if m == nil {
		return nil
	}
	return m.Product
}

func (m *MakeDecisionGlobals) GetVersion() *string {
	if m == nil {
		return nil
	}
	return m.Version
}

func (m *MakeDecisionGlobals) GetPlatform() *string {
	if m == nil {
		return nil
	}
	return m.Platform
}

func (m *MakeDecisionGlobals) GetPlatformVersion() *string {
	if m == nil {
		return nil
	}
	return m.PlatformVersion
}

func (m *MakeDecisionGlobals) GetDevice() *string {
	if m == nil {
		return nil
	}
	return m.Device
}

func (m *MakeDecisionGlobals) GetModel() *string {
	if m == nil {
		return nil
	}
	return m.Model
}

func (m *MakeDecisionGlobals) GetDeviceVendor() *string {
	if m == nil {
		return nil
	}
	return m.DeviceVendor
}

func (m *MakeDecisionGlobals) GetDeviceName() *string {
	if m == nil {
		return nil
	}
	return m.DeviceName
}

func (m *MakeDecisionGlobals) GetMarketplace() *string {
	if m == nil {
		return nil
	}
	return m.Marketplace
}

// Location - Network type of the client, can be used to help determine target bitrate.
type Location string

const (
	LocationLan      Location = "lan"
	LocationWan      Location = "wan"
	LocationCellular Location = "cellular"
)

func (e Location) ToPointer() *Location {
	return &e
}
func (e *Location) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "lan":
		fallthrough
	case "wan":
		fallthrough
	case "cellular":
		*e = Location(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Location: %v", v)
	}
}

// Protocol - Indicates the network streaming protocol to be used for the transcode session: * 'http' - include the file in the http response such as MKV streaming * 'hls' - hls stream (RFC 8216) * 'dash' - dash stream (ISO/IEC 23009-1:2022)
type Protocol string

const (
	ProtocolHTTP Protocol = "http"
	ProtocolHls  Protocol = "hls"
	ProtocolDash Protocol = "dash"
)

func (e Protocol) ToPointer() *Protocol {
	return &e
}
func (e *Protocol) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "http":
		fallthrough
	case "hls":
		fallthrough
	case "dash":
		*e = Protocol(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Protocol: %v", v)
	}
}

// Subtitles - Indicates how subtitles should be included: * 'auto' - Compute the appropriate subtitle setting automatically * 'burn' - Burn the selected subtitle; auto if no selected subtitle * 'none' - Ignore all subtitle streams * 'sidecar' - The selected subtitle should be provided as a sidecar * 'embedded' - The selected subtitle should be provided as an embedded stream * 'segmented' - The selected subtitle should be provided as a segmented stream
type Subtitles string

const (
	SubtitlesAuto      Subtitles = "auto"
	SubtitlesBurn      Subtitles = "burn"
	SubtitlesNone      Subtitles = "none"
	SubtitlesSidecar   Subtitles = "sidecar"
	SubtitlesEmbedded  Subtitles = "embedded"
	SubtitlesSegmented Subtitles = "segmented"
	SubtitlesUnknown   Subtitles = "unknown"
)

func (e Subtitles) ToPointer() *Subtitles {
	return &e
}
func (e *Subtitles) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "auto":
		fallthrough
	case "burn":
		fallthrough
	case "none":
		fallthrough
	case "sidecar":
		fallthrough
	case "embedded":
		fallthrough
	case "segmented":
		fallthrough
	case "unknown":
		*e = Subtitles(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Subtitles: %v", v)
	}
}

type MakeDecisionRequest struct {
	// Indicates the client accepts the indicated media types
	Accepts *components.Accepts `default:"application/xml" header:"style=simple,explode=false,name=accepts"`
	// An opaque identifier unique to the client
	ClientIdentifier *string `header:"style=simple,explode=false,name=X-Plex-Client-Identifier"`
	// The name of the client product
	Product *string `header:"style=simple,explode=false,name=X-Plex-Product"`
	// The version of the client application
	Version *string `header:"style=simple,explode=false,name=X-Plex-Version"`
	// The platform of the client
	Platform *string `header:"style=simple,explode=false,name=X-Plex-Platform"`
	// The version of the platform
	PlatformVersion *string `header:"style=simple,explode=false,name=X-Plex-Platform-Version"`
	// A relatively friendly name for the client device
	Device *string `header:"style=simple,explode=false,name=X-Plex-Device"`
	// A potentially less friendly identifier for the device model
	Model *string `header:"style=simple,explode=false,name=X-Plex-Model"`
	// The device vendor
	DeviceVendor *string `header:"style=simple,explode=false,name=X-Plex-Device-Vendor"`
	// A friendly name for the client
	DeviceName *string `header:"style=simple,explode=false,name=X-Plex-Device-Name"`
	// The marketplace on which the client application is distributed
	Marketplace *string `header:"style=simple,explode=false,name=X-Plex-Marketplace"`
	// Type of transcode media
	TranscodeType components.TranscodeType `pathParam:"style=simple,explode=false,name=transcodeType"`
	// Transcode session UUID
	TranscodeSessionID *string `queryParam:"style=form,explode=true,name=transcodeSessionId"`
	// Indicates how incompatible advanced subtitles (such as ass/ssa) should be included: * 'burn' - Burn incompatible advanced text subtitles into the video stream * 'text' - Transcode incompatible advanced text subtitles to a compatible text format, even if some markup is lost
	//
	AdvancedSubtitles *components.AdvancedSubtitles `queryParam:"style=form,explode=true,name=advancedSubtitles"`
	// Percentage of original audio loudness to use when transcoding (100 is equivalent to original volume, 50 is half, 200 is double, etc)
	AudioBoost *int64 `queryParam:"style=form,explode=true,name=audioBoost"`
	// Target video number of audio channels.
	AudioChannelCount *int64 `queryParam:"style=form,explode=true,name=audioChannelCount"`
	// Indicates the client supports ABR.
	AutoAdjustQuality *components.BoolInt `queryParam:"style=form,explode=true,name=autoAdjustQuality"`
	// Indicates if the server should adjust subtitles based on Voice Activity Data.
	AutoAdjustSubtitle *components.BoolInt `queryParam:"style=form,explode=true,name=autoAdjustSubtitle"`
	// Indicates the client supports direct playing the indicated content.
	DirectPlay *components.BoolInt `queryParam:"style=form,explode=true,name=directPlay"`
	// Indicates the client supports direct streaming the video of the indicated content.
	DirectStream *components.BoolInt `queryParam:"style=form,explode=true,name=directStream"`
	// Indicates the client supports direct streaming the audio of the indicated content.
	DirectStreamAudio *components.BoolInt `queryParam:"style=form,explode=true,name=directStreamAudio"`
	// Indicates if resolution should be adjusted for orientation.
	DisableResolutionRotation *components.BoolInt `queryParam:"style=form,explode=true,name=disableResolutionRotation"`
	// Ignore client profiles when determining if direct play is possible. Only has an effect when directPlay=1 and both mediaIndex and partIndex are specified and neither are -1
	HasMDE *components.BoolInt `queryParam:"style=form,explode=true,name=hasMDE"`
	// Network type of the client, can be used to help determine target bitrate.
	Location *Location `queryParam:"style=form,explode=true,name=location"`
	// Buffer size used in playback (in KB). Clients should specify a lower bound if not known exactly. This value could make the difference between transcoding and direct play on bandwidth constrained networks.
	MediaBufferSize *int64 `queryParam:"style=form,explode=true,name=mediaBufferSize"`
	// Index of the media to transcode. -1 or not specified indicates let the server choose.
	MediaIndex *int64 `queryParam:"style=form,explode=true,name=mediaIndex"`
	// Target bitrate for audio only files (in kbps, used to transcode).
	MusicBitrate *int64 `queryParam:"style=form,explode=true,name=musicBitrate"`
	// Offset from the start of the media (in seconds).
	Offset *float64 `queryParam:"style=form,explode=true,name=offset"`
	// Index of the part to transcode. -1 or not specified indicates the server should join parts together in a transcode
	PartIndex *int64 `queryParam:"style=form,explode=true,name=partIndex"`
	// Internal PMS path of the media to transcode.
	Path *string `queryParam:"style=form,explode=true,name=path"`
	// Maximum bitrate (in kbps) to use in ABR.
	PeakBitrate *int64 `queryParam:"style=form,explode=true,name=peakBitrate"`
	// Target photo resolution.
	PhotoResolution *string `queryParam:"style=form,explode=true,name=photoResolution"`
	// Indicates the network streaming protocol to be used for the transcode session: * 'http' - include the file in the http response such as MKV streaming * 'hls' - hls stream (RFC 8216) * 'dash' - dash stream (ISO/IEC 23009-1:2022)
	//
	Protocol *Protocol `queryParam:"style=form,explode=true,name=protocol"`
	// Number of seconds to include in each transcoded segment
	SecondsPerSegment *int64 `queryParam:"style=form,explode=true,name=secondsPerSegment"`
	// Percentage of original subtitle size to use when burning subtitles (100 is equivalent to original size, 50 is half, ect)
	SubtitleSize *int64 `queryParam:"style=form,explode=true,name=subtitleSize"`
	// Indicates how subtitles should be included: * 'auto' - Compute the appropriate subtitle setting automatically * 'burn' - Burn the selected subtitle; auto if no selected subtitle * 'none' - Ignore all subtitle streams * 'sidecar' - The selected subtitle should be provided as a sidecar * 'embedded' - The selected subtitle should be provided as an embedded stream * 'segmented' - The selected subtitle should be provided as a segmented stream
	//
	Subtitles *Subtitles `queryParam:"style=form,explode=true,name=subtitles"`
	// Target video bitrate (in kbps).
	VideoBitrate *int64 `queryParam:"style=form,explode=true,name=videoBitrate"`
	// Target photo quality.
	VideoQuality *int64 `queryParam:"style=form,explode=true,name=videoQuality"`
	// Target maximum video resolution.
	VideoResolution *string `queryParam:"style=form,explode=true,name=videoResolution"`
	// See [Profile Augmentations](#section/API-Info/Profile-Augmentations) .
	XPlexClientProfileExtra *string `header:"style=simple,explode=false,name=X-Plex-Client-Profile-Extra"`
	// Which built in Client Profile to use in the decision. Generally should only be used to specify the Generic profile.
	XPlexClientProfileName *string `header:"style=simple,explode=false,name=X-Plex-Client-Profile-Name"`
	// Unique per client playback session.  Used if a client can playback multiple items at a time (such as a browser with multiple tabs)
	XPlexSessionIdentifier *string `header:"style=simple,explode=false,name=X-Plex-Session-Identifier"`
}

func (m MakeDecisionRequest) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MakeDecisionRequest) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, []string{"transcodeType"}); err != nil {
		return err
	}
	return nil
}

func (m *MakeDecisionRequest) GetAccepts() *components.Accepts {
	if m == nil {
		return nil
	}
	return m.Accepts
}

func (m *MakeDecisionRequest) GetClientIdentifier() *string {
	if m == nil {
		return nil
	}
	return m.ClientIdentifier
}

func (m *MakeDecisionRequest) GetProduct() *string {
	if m == nil {
		return nil
	}
	return m.Product
}

func (m *MakeDecisionRequest) GetVersion() *string {
	if m == nil {
		return nil
	}
	return m.Version
}

func (m *MakeDecisionRequest) GetPlatform() *string {
	if m == nil {
		return nil
	}
	return m.Platform
}

func (m *MakeDecisionRequest) GetPlatformVersion() *string {
	if m == nil {
		return nil
	}
	return m.PlatformVersion
}

func (m *MakeDecisionRequest) GetDevice() *string {
	if m == nil {
		return nil
	}
	return m.Device
}

func (m *MakeDecisionRequest) GetModel() *string {
	if m == nil {
		return nil
	}
	return m.Model
}

func (m *MakeDecisionRequest) GetDeviceVendor() *string {
	if m == nil {
		return nil
	}
	return m.DeviceVendor
}

func (m *MakeDecisionRequest) GetDeviceName() *string {
	if m == nil {
		return nil
	}
	return m.DeviceName
}

func (m *MakeDecisionRequest) GetMarketplace() *string {
	if m == nil {
		return nil
	}
	return m.Marketplace
}

func (m *MakeDecisionRequest) GetTranscodeType() components.TranscodeType {
	if m == nil {
		return components.TranscodeType("")
	}
	return m.TranscodeType
}

func (m *MakeDecisionRequest) GetTranscodeSessionID() *string {
	if m == nil {
		return nil
	}
	return m.TranscodeSessionID
}

func (m *MakeDecisionRequest) GetAdvancedSubtitles() *components.AdvancedSubtitles {
	if m == nil {
		return nil
	}
	return m.AdvancedSubtitles
}

func (m *MakeDecisionRequest) GetAudioBoost() *int64 {
	if m == nil {
		return nil
	}
	return m.AudioBoost
}

func (m *MakeDecisionRequest) GetAudioChannelCount() *int64 {
	if m == nil {
		return nil
	}
	return m.AudioChannelCount
}

func (m *MakeDecisionRequest) GetAutoAdjustQuality() *components.BoolInt {
	if m == nil {
		return nil
	}
	return m.AutoAdjustQuality
}

func (m *MakeDecisionRequest) GetAutoAdjustSubtitle() *components.BoolInt {
	if m == nil {
		return nil
	}
	return m.AutoAdjustSubtitle
}

func (m *MakeDecisionRequest) GetDirectPlay() *components.BoolInt {
	if m == nil {
		return nil
	}
	return m.DirectPlay
}

func (m *MakeDecisionRequest) GetDirectStream() *components.BoolInt {
	if m == nil {
		return nil
	}
	return m.DirectStream
}

func (m *MakeDecisionRequest) GetDirectStreamAudio() *components.BoolInt {
	if m == nil {
		return nil
	}
	return m.DirectStreamAudio
}

func (m *MakeDecisionRequest) GetDisableResolutionRotation() *components.BoolInt {
	if m == nil {
		return nil
	}
	return m.DisableResolutionRotation
}

func (m *MakeDecisionRequest) GetHasMDE() *components.BoolInt {
	if m == nil {
		return nil
	}
	return m.HasMDE
}

func (m *MakeDecisionRequest) GetLocation() *Location {
	if m == nil {
		return nil
	}
	return m.Location
}

func (m *MakeDecisionRequest) GetMediaBufferSize() *int64 {
	if m == nil {
		return nil
	}
	return m.MediaBufferSize
}

func (m *MakeDecisionRequest) GetMediaIndex() *int64 {
	if m == nil {
		return nil
	}
	return m.MediaIndex
}

func (m *MakeDecisionRequest) GetMusicBitrate() *int64 {
	if m == nil {
		return nil
	}
	return m.MusicBitrate
}

func (m *MakeDecisionRequest) GetOffset() *float64 {
	if m == nil {
		return nil
	}
	return m.Offset
}

func (m *MakeDecisionRequest) GetPartIndex() *int64 {
	if m == nil {
		return nil
	}
	return m.PartIndex
}

func (m *MakeDecisionRequest) GetPath() *string {
	if m == nil {
		return nil
	}
	return m.Path
}

func (m *MakeDecisionRequest) GetPeakBitrate() *int64 {
	if m == nil {
		return nil
	}
	return m.PeakBitrate
}

func (m *MakeDecisionRequest) GetPhotoResolution() *string {
	if m == nil {
		return nil
	}
	return m.PhotoResolution
}

func (m *MakeDecisionRequest) GetProtocol() *Protocol {
	if m == nil {
		return nil
	}
	return m.Protocol
}

func (m *MakeDecisionRequest) GetSecondsPerSegment() *int64 {
	if m == nil {
		return nil
	}
	return m.SecondsPerSegment
}

func (m *MakeDecisionRequest) GetSubtitleSize() *int64 {
	if m == nil {
		return nil
	}
	return m.SubtitleSize
}

func (m *MakeDecisionRequest) GetSubtitles() *Subtitles {
	if m == nil {
		return nil
	}
	return m.Subtitles
}

func (m *MakeDecisionRequest) GetVideoBitrate() *int64 {
	if m == nil {
		return nil
	}
	return m.VideoBitrate
}

func (m *MakeDecisionRequest) GetVideoQuality() *int64 {
	if m == nil {
		return nil
	}
	return m.VideoQuality
}

func (m *MakeDecisionRequest) GetVideoResolution() *string {
	if m == nil {
		return nil
	}
	return m.VideoResolution
}

func (m *MakeDecisionRequest) GetXPlexClientProfileExtra() *string {
	if m == nil {
		return nil
	}
	return m.XPlexClientProfileExtra
}

func (m *MakeDecisionRequest) GetXPlexClientProfileName() *string {
	if m == nil {
		return nil
	}
	return m.XPlexClientProfileName
}

func (m *MakeDecisionRequest) GetXPlexSessionIdentifier() *string {
	if m == nil {
		return nil
	}
	return m.XPlexSessionIdentifier
}

type MakeDecisionResponse struct {
	// HTTP response content type for this operation
	ContentType string
	// HTTP response status code for this operation
	StatusCode int
	// Raw HTTP response; suitable for custom response parsing
	RawResponse *http.Response
	// OK
	MediaContainerWithDecision *components.MediaContainerWithDecision
}

func (m *MakeDecisionResponse) GetContentType() string {
	if m == nil {
		return ""
	}
	return m.ContentType
}

func (m *MakeDecisionResponse) GetStatusCode() int {
	if m == nil {
		return 0
	}
	return m.StatusCode
}

func (m *MakeDecisionResponse) GetRawResponse() *http.Response {
	if m == nil {
		return nil
	}
	return m.RawResponse
}

func (m *MakeDecisionResponse) GetMediaContainerWithDecision() *components.MediaContainerWithDecision {
	if m == nil {
		return nil
	}
	return m.MediaContainerWithDecision
}
