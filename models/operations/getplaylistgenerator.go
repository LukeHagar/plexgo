// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"github.com/LukeHagar/plexgo/internal/utils"
	"github.com/LukeHagar/plexgo/models/components"
	"net/http"
)

type GetPlaylistGeneratorGlobals struct {
	// Indicates the client accepts the indicated media types
	Accepts *components.Accepts `default:"application/xml" header:"style=simple,explode=false,name=accepts"`
	// An opaque identifier unique to the client
	ClientIdentifier *string `header:"style=simple,explode=false,name=X-Plex-Client-Identifier"`
	// The name of the client product
	Product *string `header:"style=simple,explode=false,name=X-Plex-Product"`
	// The version of the client application
	Version *string `header:"style=simple,explode=false,name=X-Plex-Version"`
	// The platform of the client
	Platform *string `header:"style=simple,explode=false,name=X-Plex-Platform"`
	// The version of the platform
	PlatformVersion *string `header:"style=simple,explode=false,name=X-Plex-Platform-Version"`
	// A relatively friendly name for the client device
	Device *string `header:"style=simple,explode=false,name=X-Plex-Device"`
	// A potentially less friendly identifier for the device model
	Model *string `header:"style=simple,explode=false,name=X-Plex-Model"`
	// The device vendor
	DeviceVendor *string `header:"style=simple,explode=false,name=X-Plex-Device-Vendor"`
	// A friendly name for the client
	DeviceName *string `header:"style=simple,explode=false,name=X-Plex-Device-Name"`
	// The marketplace on which the client application is distributed
	Marketplace *string `header:"style=simple,explode=false,name=X-Plex-Marketplace"`
}

func (g GetPlaylistGeneratorGlobals) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetPlaylistGeneratorGlobals) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (g *GetPlaylistGeneratorGlobals) GetAccepts() *components.Accepts {
	if g == nil {
		return nil
	}
	return g.Accepts
}

func (g *GetPlaylistGeneratorGlobals) GetClientIdentifier() *string {
	if g == nil {
		return nil
	}
	return g.ClientIdentifier
}

func (g *GetPlaylistGeneratorGlobals) GetProduct() *string {
	if g == nil {
		return nil
	}
	return g.Product
}

func (g *GetPlaylistGeneratorGlobals) GetVersion() *string {
	if g == nil {
		return nil
	}
	return g.Version
}

func (g *GetPlaylistGeneratorGlobals) GetPlatform() *string {
	if g == nil {
		return nil
	}
	return g.Platform
}

func (g *GetPlaylistGeneratorGlobals) GetPlatformVersion() *string {
	if g == nil {
		return nil
	}
	return g.PlatformVersion
}

func (g *GetPlaylistGeneratorGlobals) GetDevice() *string {
	if g == nil {
		return nil
	}
	return g.Device
}

func (g *GetPlaylistGeneratorGlobals) GetModel() *string {
	if g == nil {
		return nil
	}
	return g.Model
}

func (g *GetPlaylistGeneratorGlobals) GetDeviceVendor() *string {
	if g == nil {
		return nil
	}
	return g.DeviceVendor
}

func (g *GetPlaylistGeneratorGlobals) GetDeviceName() *string {
	if g == nil {
		return nil
	}
	return g.DeviceName
}

func (g *GetPlaylistGeneratorGlobals) GetMarketplace() *string {
	if g == nil {
		return nil
	}
	return g.Marketplace
}

type GetPlaylistGeneratorRequest struct {
	// Indicates the client accepts the indicated media types
	Accepts *components.Accepts `default:"application/xml" header:"style=simple,explode=false,name=accepts"`
	// An opaque identifier unique to the client
	ClientIdentifier *string `header:"style=simple,explode=false,name=X-Plex-Client-Identifier"`
	// The name of the client product
	Product *string `header:"style=simple,explode=false,name=X-Plex-Product"`
	// The version of the client application
	Version *string `header:"style=simple,explode=false,name=X-Plex-Version"`
	// The platform of the client
	Platform *string `header:"style=simple,explode=false,name=X-Plex-Platform"`
	// The version of the platform
	PlatformVersion *string `header:"style=simple,explode=false,name=X-Plex-Platform-Version"`
	// A relatively friendly name for the client device
	Device *string `header:"style=simple,explode=false,name=X-Plex-Device"`
	// A potentially less friendly identifier for the device model
	Model *string `header:"style=simple,explode=false,name=X-Plex-Model"`
	// The device vendor
	DeviceVendor *string `header:"style=simple,explode=false,name=X-Plex-Device-Vendor"`
	// A friendly name for the client
	DeviceName *string `header:"style=simple,explode=false,name=X-Plex-Device-Name"`
	// The marketplace on which the client application is distributed
	Marketplace *string `header:"style=simple,explode=false,name=X-Plex-Marketplace"`
	// The ID of the playlist
	PlaylistID int64 `pathParam:"style=simple,explode=false,name=playlistId"`
	// The generator item ID to delete.
	GeneratorID int64 `pathParam:"style=simple,explode=false,name=generatorId"`
}

func (g GetPlaylistGeneratorRequest) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetPlaylistGeneratorRequest) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"playlistId", "generatorId"}); err != nil {
		return err
	}
	return nil
}

func (g *GetPlaylistGeneratorRequest) GetAccepts() *components.Accepts {
	if g == nil {
		return nil
	}
	return g.Accepts
}

func (g *GetPlaylistGeneratorRequest) GetClientIdentifier() *string {
	if g == nil {
		return nil
	}
	return g.ClientIdentifier
}

func (g *GetPlaylistGeneratorRequest) GetProduct() *string {
	if g == nil {
		return nil
	}
	return g.Product
}

func (g *GetPlaylistGeneratorRequest) GetVersion() *string {
	if g == nil {
		return nil
	}
	return g.Version
}

func (g *GetPlaylistGeneratorRequest) GetPlatform() *string {
	if g == nil {
		return nil
	}
	return g.Platform
}

func (g *GetPlaylistGeneratorRequest) GetPlatformVersion() *string {
	if g == nil {
		return nil
	}
	return g.PlatformVersion
}

func (g *GetPlaylistGeneratorRequest) GetDevice() *string {
	if g == nil {
		return nil
	}
	return g.Device
}

func (g *GetPlaylistGeneratorRequest) GetModel() *string {
	if g == nil {
		return nil
	}
	return g.Model
}

func (g *GetPlaylistGeneratorRequest) GetDeviceVendor() *string {
	if g == nil {
		return nil
	}
	return g.DeviceVendor
}

func (g *GetPlaylistGeneratorRequest) GetDeviceName() *string {
	if g == nil {
		return nil
	}
	return g.DeviceName
}

func (g *GetPlaylistGeneratorRequest) GetMarketplace() *string {
	if g == nil {
		return nil
	}
	return g.Marketplace
}

func (g *GetPlaylistGeneratorRequest) GetPlaylistID() int64 {
	if g == nil {
		return 0
	}
	return g.PlaylistID
}

func (g *GetPlaylistGeneratorRequest) GetGeneratorID() int64 {
	if g == nil {
		return 0
	}
	return g.GeneratorID
}

type GetPlaylistGeneratorDevice struct {
	Profile *string `json:"profile,omitempty"`
}

func (g *GetPlaylistGeneratorDevice) GetProfile() *string {
	if g == nil {
		return nil
	}
	return g.Profile
}

type GetPlaylistGeneratorLocation struct {
	LibrarySectionID *int64  `json:"librarySectionID,omitempty"`
	URI              *string `json:"uri,omitempty"`
}

func (g *GetPlaylistGeneratorLocation) GetLibrarySectionID() *int64 {
	if g == nil {
		return nil
	}
	return g.LibrarySectionID
}

func (g *GetPlaylistGeneratorLocation) GetURI() *string {
	if g == nil {
		return nil
	}
	return g.URI
}

type AdvancedSubtitles string

const (
	AdvancedSubtitlesAuto      AdvancedSubtitles = "auto"
	AdvancedSubtitlesBurn      AdvancedSubtitles = "burn"
	AdvancedSubtitlesNone      AdvancedSubtitles = "none"
	AdvancedSubtitlesSidecar   AdvancedSubtitles = "sidecar"
	AdvancedSubtitlesEmbedded  AdvancedSubtitles = "embedded"
	AdvancedSubtitlesSegmented AdvancedSubtitles = "segmented"
)

func (e AdvancedSubtitles) ToPointer() *AdvancedSubtitles {
	return &e
}
func (e *AdvancedSubtitles) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "auto":
		fallthrough
	case "burn":
		fallthrough
	case "none":
		fallthrough
	case "sidecar":
		fallthrough
	case "embedded":
		fallthrough
	case "segmented":
		*e = AdvancedSubtitles(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AdvancedSubtitles: %v", v)
	}
}

type GetPlaylistGeneratorSubtitles string

const (
	GetPlaylistGeneratorSubtitlesAuto      GetPlaylistGeneratorSubtitles = "auto"
	GetPlaylistGeneratorSubtitlesBurn      GetPlaylistGeneratorSubtitles = "burn"
	GetPlaylistGeneratorSubtitlesNone      GetPlaylistGeneratorSubtitles = "none"
	GetPlaylistGeneratorSubtitlesSidecar   GetPlaylistGeneratorSubtitles = "sidecar"
	GetPlaylistGeneratorSubtitlesEmbedded  GetPlaylistGeneratorSubtitles = "embedded"
	GetPlaylistGeneratorSubtitlesSegmented GetPlaylistGeneratorSubtitles = "segmented"
)

func (e GetPlaylistGeneratorSubtitles) ToPointer() *GetPlaylistGeneratorSubtitles {
	return &e
}
func (e *GetPlaylistGeneratorSubtitles) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "auto":
		fallthrough
	case "burn":
		fallthrough
	case "none":
		fallthrough
	case "sidecar":
		fallthrough
	case "embedded":
		fallthrough
	case "segmented":
		*e = GetPlaylistGeneratorSubtitles(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetPlaylistGeneratorSubtitles: %v", v)
	}
}

type MediaSettings struct {
	AdvancedSubtitles         *AdvancedSubtitles             `json:"advancedSubtitles,omitempty"`
	AudioBoost                *int64                         `json:"audioBoost,omitempty"`
	AudioChannelCount         *int64                         `json:"audioChannelCount,omitempty"`
	AutoAdjustQuality         *bool                          `json:"autoAdjustQuality,omitempty"`
	AutoAdjustSubtitle        *bool                          `json:"autoAdjustSubtitle,omitempty"`
	DirectPlay                *bool                          `json:"directPlay,omitempty"`
	DirectStream              *bool                          `json:"directStream,omitempty"`
	DirectStreamAudio         *bool                          `json:"directStreamAudio,omitempty"`
	DisableResolutionRotation *bool                          `json:"disableResolutionRotation,omitempty"`
	MaxVideoBitrate           *int64                         `json:"maxVideoBitrate,omitempty"`
	MusicBitrate              *int64                         `json:"musicBitrate,omitempty"`
	PeakBitrate               *int64                         `json:"peakBitrate,omitempty"`
	PhotoQuality              *int64                         `json:"photoQuality,omitempty"`
	PhotoResolution           *string                        `json:"photoResolution,omitempty"`
	SecondsPerSegment         *int64                         `json:"secondsPerSegment,omitempty"`
	Subtitles                 *GetPlaylistGeneratorSubtitles `json:"subtitles,omitempty"`
	SubtitleSize              *int64                         `json:"subtitleSize,omitempty"`
	VideoBitrate              *int64                         `json:"videoBitrate,omitempty"`
	VideoQuality              *int64                         `json:"videoQuality,omitempty"`
	VideoResolution           *string                        `json:"videoResolution,omitempty"`
}

func (m *MediaSettings) GetAdvancedSubtitles() *AdvancedSubtitles {
	if m == nil {
		return nil
	}
	return m.AdvancedSubtitles
}

func (m *MediaSettings) GetAudioBoost() *int64 {
	if m == nil {
		return nil
	}
	return m.AudioBoost
}

func (m *MediaSettings) GetAudioChannelCount() *int64 {
	if m == nil {
		return nil
	}
	return m.AudioChannelCount
}

func (m *MediaSettings) GetAutoAdjustQuality() *bool {
	if m == nil {
		return nil
	}
	return m.AutoAdjustQuality
}

func (m *MediaSettings) GetAutoAdjustSubtitle() *bool {
	if m == nil {
		return nil
	}
	return m.AutoAdjustSubtitle
}

func (m *MediaSettings) GetDirectPlay() *bool {
	if m == nil {
		return nil
	}
	return m.DirectPlay
}

func (m *MediaSettings) GetDirectStream() *bool {
	if m == nil {
		return nil
	}
	return m.DirectStream
}

func (m *MediaSettings) GetDirectStreamAudio() *bool {
	if m == nil {
		return nil
	}
	return m.DirectStreamAudio
}

func (m *MediaSettings) GetDisableResolutionRotation() *bool {
	if m == nil {
		return nil
	}
	return m.DisableResolutionRotation
}

func (m *MediaSettings) GetMaxVideoBitrate() *int64 {
	if m == nil {
		return nil
	}
	return m.MaxVideoBitrate
}

func (m *MediaSettings) GetMusicBitrate() *int64 {
	if m == nil {
		return nil
	}
	return m.MusicBitrate
}

func (m *MediaSettings) GetPeakBitrate() *int64 {
	if m == nil {
		return nil
	}
	return m.PeakBitrate
}

func (m *MediaSettings) GetPhotoQuality() *int64 {
	if m == nil {
		return nil
	}
	return m.PhotoQuality
}

func (m *MediaSettings) GetPhotoResolution() *string {
	if m == nil {
		return nil
	}
	return m.PhotoResolution
}

func (m *MediaSettings) GetSecondsPerSegment() *int64 {
	if m == nil {
		return nil
	}
	return m.SecondsPerSegment
}

func (m *MediaSettings) GetSubtitles() *GetPlaylistGeneratorSubtitles {
	if m == nil {
		return nil
	}
	return m.Subtitles
}

func (m *MediaSettings) GetSubtitleSize() *int64 {
	if m == nil {
		return nil
	}
	return m.SubtitleSize
}

func (m *MediaSettings) GetVideoBitrate() *int64 {
	if m == nil {
		return nil
	}
	return m.VideoBitrate
}

func (m *MediaSettings) GetVideoQuality() *int64 {
	if m == nil {
		return nil
	}
	return m.VideoQuality
}

func (m *MediaSettings) GetVideoResolution() *string {
	if m == nil {
		return nil
	}
	return m.VideoResolution
}

type GetPlaylistGeneratorScope string

const (
	GetPlaylistGeneratorScopeAll   GetPlaylistGeneratorScope = "all"
	GetPlaylistGeneratorScopeCount GetPlaylistGeneratorScope = "count"
)

func (e GetPlaylistGeneratorScope) ToPointer() *GetPlaylistGeneratorScope {
	return &e
}
func (e *GetPlaylistGeneratorScope) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "all":
		fallthrough
	case "count":
		*e = GetPlaylistGeneratorScope(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetPlaylistGeneratorScope: %v", v)
	}
}

type GetPlaylistGeneratorPolicy struct {
	Scope *GetPlaylistGeneratorScope `json:"scope,omitempty"`
	// True if only unwatched items are optimized
	Unwatched *bool `json:"unwatched,omitempty"`
	// If the scope is count, the number of items to optimize
	Value *int64 `json:"value,omitempty"`
}

func (g *GetPlaylistGeneratorPolicy) GetScope() *GetPlaylistGeneratorScope {
	if g == nil {
		return nil
	}
	return g.Scope
}

func (g *GetPlaylistGeneratorPolicy) GetUnwatched() *bool {
	if g == nil {
		return nil
	}
	return g.Unwatched
}

func (g *GetPlaylistGeneratorPolicy) GetValue() *int64 {
	if g == nil {
		return nil
	}
	return g.Value
}

type GetPlaylistGeneratorState string

const (
	GetPlaylistGeneratorStatePending  GetPlaylistGeneratorState = "pending"
	GetPlaylistGeneratorStateComplete GetPlaylistGeneratorState = "complete"
	GetPlaylistGeneratorStateFailed   GetPlaylistGeneratorState = "failed"
)

func (e GetPlaylistGeneratorState) ToPointer() *GetPlaylistGeneratorState {
	return &e
}
func (e *GetPlaylistGeneratorState) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "pending":
		fallthrough
	case "complete":
		fallthrough
	case "failed":
		*e = GetPlaylistGeneratorState(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetPlaylistGeneratorState: %v", v)
	}
}

type GetPlaylistGeneratorStatus struct {
	ItemsCompleteCount   *int64                     `json:"itemsCompleteCount,omitempty"`
	ItemsCount           *int64                     `json:"itemsCount,omitempty"`
	ItemsSuccessfulCount *int64                     `json:"itemsSuccessfulCount,omitempty"`
	State                *GetPlaylistGeneratorState `json:"state,omitempty"`
	TotalSize            *int64                     `json:"totalSize,omitempty"`
}

func (g *GetPlaylistGeneratorStatus) GetItemsCompleteCount() *int64 {
	if g == nil {
		return nil
	}
	return g.ItemsCompleteCount
}

func (g *GetPlaylistGeneratorStatus) GetItemsCount() *int64 {
	if g == nil {
		return nil
	}
	return g.ItemsCount
}

func (g *GetPlaylistGeneratorStatus) GetItemsSuccessfulCount() *int64 {
	if g == nil {
		return nil
	}
	return g.ItemsSuccessfulCount
}

func (g *GetPlaylistGeneratorStatus) GetState() *GetPlaylistGeneratorState {
	if g == nil {
		return nil
	}
	return g.State
}

func (g *GetPlaylistGeneratorStatus) GetTotalSize() *int64 {
	if g == nil {
		return nil
	}
	return g.TotalSize
}

// GetPlaylistGeneratorType - The type of this generator
type GetPlaylistGeneratorType int64

const (
	GetPlaylistGeneratorTypeMinus1   GetPlaylistGeneratorType = -1
	GetPlaylistGeneratorTypeFortyTwo GetPlaylistGeneratorType = 42
)

func (e GetPlaylistGeneratorType) ToPointer() *GetPlaylistGeneratorType {
	return &e
}
func (e *GetPlaylistGeneratorType) UnmarshalJSON(data []byte) error {
	var v int64
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case -1:
		fallthrough
	case 42:
		*e = GetPlaylistGeneratorType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetPlaylistGeneratorType: %v", v)
	}
}

type GetPlaylistGeneratorItem struct {
	// The composite thumbnail image path
	Composite     *string                       `json:"composite,omitempty"`
	Device        *GetPlaylistGeneratorDevice   `json:"Device,omitempty"`
	ID            *int64                        `json:"id,omitempty"`
	Location      *GetPlaylistGeneratorLocation `json:"Location,omitempty"`
	MediaSettings *MediaSettings                `json:"MediaSettings,omitempty"`
	Policy        *GetPlaylistGeneratorPolicy   `json:"Policy,omitempty"`
	Status        *GetPlaylistGeneratorStatus   `json:"Status,omitempty"`
	Target        *string                       `json:"target,omitempty"`
	// The tag of this generator's settings
	TargetTagID *int64  `json:"targetTagID,omitempty"`
	Title       *string `json:"title,omitempty"`
	// The type of this generator
	Type *GetPlaylistGeneratorType `json:"type,omitempty"`
}

func (g *GetPlaylistGeneratorItem) GetComposite() *string {
	if g == nil {
		return nil
	}
	return g.Composite
}

func (g *GetPlaylistGeneratorItem) GetDevice() *GetPlaylistGeneratorDevice {
	if g == nil {
		return nil
	}
	return g.Device
}

func (g *GetPlaylistGeneratorItem) GetID() *int64 {
	if g == nil {
		return nil
	}
	return g.ID
}

func (g *GetPlaylistGeneratorItem) GetLocation() *GetPlaylistGeneratorLocation {
	if g == nil {
		return nil
	}
	return g.Location
}

func (g *GetPlaylistGeneratorItem) GetMediaSettings() *MediaSettings {
	if g == nil {
		return nil
	}
	return g.MediaSettings
}

func (g *GetPlaylistGeneratorItem) GetPolicy() *GetPlaylistGeneratorPolicy {
	if g == nil {
		return nil
	}
	return g.Policy
}

func (g *GetPlaylistGeneratorItem) GetStatus() *GetPlaylistGeneratorStatus {
	if g == nil {
		return nil
	}
	return g.Status
}

func (g *GetPlaylistGeneratorItem) GetTarget() *string {
	if g == nil {
		return nil
	}
	return g.Target
}

func (g *GetPlaylistGeneratorItem) GetTargetTagID() *int64 {
	if g == nil {
		return nil
	}
	return g.TargetTagID
}

func (g *GetPlaylistGeneratorItem) GetTitle() *string {
	if g == nil {
		return nil
	}
	return g.Title
}

func (g *GetPlaylistGeneratorItem) GetType() *GetPlaylistGeneratorType {
	if g == nil {
		return nil
	}
	return g.Type
}

// GetPlaylistGeneratorMediaContainer - `MediaContainer` is the root element of most Plex API responses. It serves as a generic container for various types of content (Metadata, Hubs, Directories, etc.) and includes pagination information (offset, size, totalSize) when applicable.
// Common attributes: - identifier: Unique identifier for this container - size: Number of items in this response page - totalSize: Total number of items available (for pagination) - offset: Starting index of this page (for pagination)
// The container often "hoists" common attributes from its children. For example, if all tracks in a container share the same album title, the `parentTitle` attribute may appear on the MediaContainer rather than being repeated on each track.
type GetPlaylistGeneratorMediaContainer struct {
	Identifier *string `json:"identifier,omitempty"`
	// The offset of where this container page starts among the total objects available. Also provided in the `X-Plex-Container-Start` header.
	//
	Offset *int64 `json:"offset,omitempty"`
	Size   *int64 `json:"size,omitempty"`
	// The total size of objects available. Also provided in the `X-Plex-Container-Total-Size` header.
	//
	TotalSize *int64                     `json:"totalSize,omitempty"`
	Item      []GetPlaylistGeneratorItem `json:"Item,omitempty"`
}

func (g *GetPlaylistGeneratorMediaContainer) GetIdentifier() *string {
	if g == nil {
		return nil
	}
	return g.Identifier
}

func (g *GetPlaylistGeneratorMediaContainer) GetOffset() *int64 {
	if g == nil {
		return nil
	}
	return g.Offset
}

func (g *GetPlaylistGeneratorMediaContainer) GetSize() *int64 {
	if g == nil {
		return nil
	}
	return g.Size
}

func (g *GetPlaylistGeneratorMediaContainer) GetTotalSize() *int64 {
	if g == nil {
		return nil
	}
	return g.TotalSize
}

func (g *GetPlaylistGeneratorMediaContainer) GetItem() []GetPlaylistGeneratorItem {
	if g == nil {
		return nil
	}
	return g.Item
}

// GetPlaylistGeneratorResponseBody - OK
type GetPlaylistGeneratorResponseBody struct {
	MediaContainer *GetPlaylistGeneratorMediaContainer `json:"MediaContainer,omitempty"`
}

func (g *GetPlaylistGeneratorResponseBody) GetMediaContainer() *GetPlaylistGeneratorMediaContainer {
	if g == nil {
		return nil
	}
	return g.MediaContainer
}

type GetPlaylistGeneratorResponse struct {
	// HTTP response content type for this operation
	ContentType string
	// HTTP response status code for this operation
	StatusCode int
	// Raw HTTP response; suitable for custom response parsing
	RawResponse *http.Response
	// OK
	Object *GetPlaylistGeneratorResponseBody
}

func (g *GetPlaylistGeneratorResponse) GetContentType() string {
	if g == nil {
		return ""
	}
	return g.ContentType
}

func (g *GetPlaylistGeneratorResponse) GetStatusCode() int {
	if g == nil {
		return 0
	}
	return g.StatusCode
}

func (g *GetPlaylistGeneratorResponse) GetRawResponse() *http.Response {
	if g == nil {
		return nil
	}
	return g.RawResponse
}

func (g *GetPlaylistGeneratorResponse) GetObject() *GetPlaylistGeneratorResponseBody {
	if g == nil {
		return nil
	}
	return g.Object
}
