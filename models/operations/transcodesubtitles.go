// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"github.com/LukeHagar/plexgo/internal/utils"
	"github.com/LukeHagar/plexgo/models/components"
	"net/http"
)

type TranscodeSubtitlesGlobals struct {
	// Indicates the client accepts the indicated media types
	Accepts *components.Accepts `default:"application/xml" header:"style=simple,explode=false,name=accepts"`
	// An opaque identifier unique to the client
	ClientIdentifier *string `header:"style=simple,explode=false,name=X-Plex-Client-Identifier"`
	// The name of the client product
	Product *string `header:"style=simple,explode=false,name=X-Plex-Product"`
	// The version of the client application
	Version *string `header:"style=simple,explode=false,name=X-Plex-Version"`
	// The platform of the client
	Platform *string `header:"style=simple,explode=false,name=X-Plex-Platform"`
	// The version of the platform
	PlatformVersion *string `header:"style=simple,explode=false,name=X-Plex-Platform-Version"`
	// A relatively friendly name for the client device
	Device *string `header:"style=simple,explode=false,name=X-Plex-Device"`
	// A potentially less friendly identifier for the device model
	Model *string `header:"style=simple,explode=false,name=X-Plex-Model"`
	// The device vendor
	DeviceVendor *string `header:"style=simple,explode=false,name=X-Plex-Device-Vendor"`
	// A friendly name for the client
	DeviceName *string `header:"style=simple,explode=false,name=X-Plex-Device-Name"`
	// The marketplace on which the client application is distributed
	Marketplace *string `header:"style=simple,explode=false,name=X-Plex-Marketplace"`
}

func (t TranscodeSubtitlesGlobals) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TranscodeSubtitlesGlobals) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (t *TranscodeSubtitlesGlobals) GetAccepts() *components.Accepts {
	if t == nil {
		return nil
	}
	return t.Accepts
}

func (t *TranscodeSubtitlesGlobals) GetClientIdentifier() *string {
	if t == nil {
		return nil
	}
	return t.ClientIdentifier
}

func (t *TranscodeSubtitlesGlobals) GetProduct() *string {
	if t == nil {
		return nil
	}
	return t.Product
}

func (t *TranscodeSubtitlesGlobals) GetVersion() *string {
	if t == nil {
		return nil
	}
	return t.Version
}

func (t *TranscodeSubtitlesGlobals) GetPlatform() *string {
	if t == nil {
		return nil
	}
	return t.Platform
}

func (t *TranscodeSubtitlesGlobals) GetPlatformVersion() *string {
	if t == nil {
		return nil
	}
	return t.PlatformVersion
}

func (t *TranscodeSubtitlesGlobals) GetDevice() *string {
	if t == nil {
		return nil
	}
	return t.Device
}

func (t *TranscodeSubtitlesGlobals) GetModel() *string {
	if t == nil {
		return nil
	}
	return t.Model
}

func (t *TranscodeSubtitlesGlobals) GetDeviceVendor() *string {
	if t == nil {
		return nil
	}
	return t.DeviceVendor
}

func (t *TranscodeSubtitlesGlobals) GetDeviceName() *string {
	if t == nil {
		return nil
	}
	return t.DeviceName
}

func (t *TranscodeSubtitlesGlobals) GetMarketplace() *string {
	if t == nil {
		return nil
	}
	return t.Marketplace
}

// QueryParamLocation - Network type of the client, can be used to help determine target bitrate.
type QueryParamLocation string

const (
	QueryParamLocationLan      QueryParamLocation = "lan"
	QueryParamLocationWan      QueryParamLocation = "wan"
	QueryParamLocationCellular QueryParamLocation = "cellular"
)

func (e QueryParamLocation) ToPointer() *QueryParamLocation {
	return &e
}
func (e *QueryParamLocation) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "lan":
		fallthrough
	case "wan":
		fallthrough
	case "cellular":
		*e = QueryParamLocation(v)
		return nil
	default:
		return fmt.Errorf("invalid value for QueryParamLocation: %v", v)
	}
}

// QueryParamProtocol - Indicates the network streaming protocol to be used for the transcode session: * 'http' - include the file in the http response such as MKV streaming * 'hls' - hls stream (RFC 8216) * 'dash' - dash stream (ISO/IEC 23009-1:2022)
type QueryParamProtocol string

const (
	QueryParamProtocolHTTP QueryParamProtocol = "http"
	QueryParamProtocolHls  QueryParamProtocol = "hls"
	QueryParamProtocolDash QueryParamProtocol = "dash"
)

func (e QueryParamProtocol) ToPointer() *QueryParamProtocol {
	return &e
}
func (e *QueryParamProtocol) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "http":
		fallthrough
	case "hls":
		fallthrough
	case "dash":
		*e = QueryParamProtocol(v)
		return nil
	default:
		return fmt.Errorf("invalid value for QueryParamProtocol: %v", v)
	}
}

// QueryParamSubtitles - Indicates how subtitles should be included: * 'auto' - Compute the appropriate subtitle setting automatically * 'burn' - Burn the selected subtitle; auto if no selected subtitle * 'none' - Ignore all subtitle streams * 'sidecar' - The selected subtitle should be provided as a sidecar * 'embedded' - The selected subtitle should be provided as an embedded stream * 'segmented' - The selected subtitle should be provided as a segmented stream
type QueryParamSubtitles string

const (
	QueryParamSubtitlesAuto      QueryParamSubtitles = "auto"
	QueryParamSubtitlesBurn      QueryParamSubtitles = "burn"
	QueryParamSubtitlesNone      QueryParamSubtitles = "none"
	QueryParamSubtitlesSidecar   QueryParamSubtitles = "sidecar"
	QueryParamSubtitlesEmbedded  QueryParamSubtitles = "embedded"
	QueryParamSubtitlesSegmented QueryParamSubtitles = "segmented"
	QueryParamSubtitlesUnknown   QueryParamSubtitles = "unknown"
)

func (e QueryParamSubtitles) ToPointer() *QueryParamSubtitles {
	return &e
}
func (e *QueryParamSubtitles) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "auto":
		fallthrough
	case "burn":
		fallthrough
	case "none":
		fallthrough
	case "sidecar":
		fallthrough
	case "embedded":
		fallthrough
	case "segmented":
		fallthrough
	case "unknown":
		*e = QueryParamSubtitles(v)
		return nil
	default:
		return fmt.Errorf("invalid value for QueryParamSubtitles: %v", v)
	}
}

type TranscodeSubtitlesRequest struct {
	// Indicates the client accepts the indicated media types
	Accepts *components.Accepts `default:"application/xml" header:"style=simple,explode=false,name=accepts"`
	// An opaque identifier unique to the client
	ClientIdentifier *string `header:"style=simple,explode=false,name=X-Plex-Client-Identifier"`
	// The name of the client product
	Product *string `header:"style=simple,explode=false,name=X-Plex-Product"`
	// The version of the client application
	Version *string `header:"style=simple,explode=false,name=X-Plex-Version"`
	// The platform of the client
	Platform *string `header:"style=simple,explode=false,name=X-Plex-Platform"`
	// The version of the platform
	PlatformVersion *string `header:"style=simple,explode=false,name=X-Plex-Platform-Version"`
	// A relatively friendly name for the client device
	Device *string `header:"style=simple,explode=false,name=X-Plex-Device"`
	// A potentially less friendly identifier for the device model
	Model *string `header:"style=simple,explode=false,name=X-Plex-Model"`
	// The device vendor
	DeviceVendor *string `header:"style=simple,explode=false,name=X-Plex-Device-Vendor"`
	// A friendly name for the client
	DeviceName *string `header:"style=simple,explode=false,name=X-Plex-Device-Name"`
	// The marketplace on which the client application is distributed
	Marketplace *string `header:"style=simple,explode=false,name=X-Plex-Marketplace"`
	// Type of transcode media
	TranscodeType components.TranscodeType `pathParam:"style=simple,explode=false,name=transcodeType"`
	// Transcode session UUID
	TranscodeSessionID *string `queryParam:"style=form,explode=true,name=transcodeSessionId"`
	// Indicates how incompatible advanced subtitles (such as ass/ssa) should be included: * 'burn' - Burn incompatible advanced text subtitles into the video stream * 'text' - Transcode incompatible advanced text subtitles to a compatible text format, even if some markup is lost
	//
	AdvancedSubtitles *components.AdvancedSubtitles `queryParam:"style=form,explode=true,name=advancedSubtitles"`
	// Percentage of original audio loudness to use when transcoding (100 is equivalent to original volume, 50 is half, 200 is double, etc)
	AudioBoost *int64 `queryParam:"style=form,explode=true,name=audioBoost"`
	// Target video number of audio channels.
	AudioChannelCount *int64 `queryParam:"style=form,explode=true,name=audioChannelCount"`
	// Indicates the client supports ABR.
	AutoAdjustQuality *components.BoolInt `queryParam:"style=form,explode=true,name=autoAdjustQuality"`
	// Indicates if the server should adjust subtitles based on Voice Activity Data.
	AutoAdjustSubtitle *components.BoolInt `queryParam:"style=form,explode=true,name=autoAdjustSubtitle"`
	// Indicates the client supports direct playing the indicated content.
	DirectPlay *components.BoolInt `queryParam:"style=form,explode=true,name=directPlay"`
	// Indicates the client supports direct streaming the video of the indicated content.
	DirectStream *components.BoolInt `queryParam:"style=form,explode=true,name=directStream"`
	// Indicates the client supports direct streaming the audio of the indicated content.
	DirectStreamAudio *components.BoolInt `queryParam:"style=form,explode=true,name=directStreamAudio"`
	// Indicates if resolution should be adjusted for orientation.
	DisableResolutionRotation *components.BoolInt `queryParam:"style=form,explode=true,name=disableResolutionRotation"`
	// Ignore client profiles when determining if direct play is possible. Only has an effect when directPlay=1 and both mediaIndex and partIndex are specified and neither are -1
	HasMDE *components.BoolInt `queryParam:"style=form,explode=true,name=hasMDE"`
	// Network type of the client, can be used to help determine target bitrate.
	Location *QueryParamLocation `queryParam:"style=form,explode=true,name=location"`
	// Buffer size used in playback (in KB). Clients should specify a lower bound if not known exactly. This value could make the difference between transcoding and direct play on bandwidth constrained networks.
	MediaBufferSize *int64 `queryParam:"style=form,explode=true,name=mediaBufferSize"`
	// Index of the media to transcode. -1 or not specified indicates let the server choose.
	MediaIndex *int64 `queryParam:"style=form,explode=true,name=mediaIndex"`
	// Target bitrate for audio only files (in kbps, used to transcode).
	MusicBitrate *int64 `queryParam:"style=form,explode=true,name=musicBitrate"`
	// Offset from the start of the media (in seconds).
	Offset *float64 `queryParam:"style=form,explode=true,name=offset"`
	// Index of the part to transcode. -1 or not specified indicates the server should join parts together in a transcode
	PartIndex *int64 `queryParam:"style=form,explode=true,name=partIndex"`
	// Internal PMS path of the media to transcode.
	Path *string `queryParam:"style=form,explode=true,name=path"`
	// Maximum bitrate (in kbps) to use in ABR.
	PeakBitrate *int64 `queryParam:"style=form,explode=true,name=peakBitrate"`
	// Target photo resolution.
	PhotoResolution *string `queryParam:"style=form,explode=true,name=photoResolution"`
	// Indicates the network streaming protocol to be used for the transcode session: * 'http' - include the file in the http response such as MKV streaming * 'hls' - hls stream (RFC 8216) * 'dash' - dash stream (ISO/IEC 23009-1:2022)
	//
	Protocol *QueryParamProtocol `queryParam:"style=form,explode=true,name=protocol"`
	// Number of seconds to include in each transcoded segment
	SecondsPerSegment *int64 `queryParam:"style=form,explode=true,name=secondsPerSegment"`
	// Percentage of original subtitle size to use when burning subtitles (100 is equivalent to original size, 50 is half, ect)
	SubtitleSize *int64 `queryParam:"style=form,explode=true,name=subtitleSize"`
	// Indicates how subtitles should be included: * 'auto' - Compute the appropriate subtitle setting automatically * 'burn' - Burn the selected subtitle; auto if no selected subtitle * 'none' - Ignore all subtitle streams * 'sidecar' - The selected subtitle should be provided as a sidecar * 'embedded' - The selected subtitle should be provided as an embedded stream * 'segmented' - The selected subtitle should be provided as a segmented stream
	//
	Subtitles *QueryParamSubtitles `queryParam:"style=form,explode=true,name=subtitles"`
	// Target video bitrate (in kbps).
	VideoBitrate *int64 `queryParam:"style=form,explode=true,name=videoBitrate"`
	// Target photo quality.
	VideoQuality *int64 `queryParam:"style=form,explode=true,name=videoQuality"`
	// Target maximum video resolution.
	VideoResolution *string `queryParam:"style=form,explode=true,name=videoResolution"`
	// See [Profile Augmentations](#section/API-Info/Profile-Augmentations) .
	XPlexClientProfileExtra *string `header:"style=simple,explode=false,name=X-Plex-Client-Profile-Extra"`
	// Which built in Client Profile to use in the decision. Generally should only be used to specify the Generic profile.
	XPlexClientProfileName *string `header:"style=simple,explode=false,name=X-Plex-Client-Profile-Name"`
	// Unique per client playback session.  Used if a client can playback multiple items at a time (such as a browser with multiple tabs)
	XPlexSessionIdentifier *string `header:"style=simple,explode=false,name=X-Plex-Session-Identifier"`
}

func (t TranscodeSubtitlesRequest) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TranscodeSubtitlesRequest) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, []string{"transcodeType"}); err != nil {
		return err
	}
	return nil
}

func (t *TranscodeSubtitlesRequest) GetAccepts() *components.Accepts {
	if t == nil {
		return nil
	}
	return t.Accepts
}

func (t *TranscodeSubtitlesRequest) GetClientIdentifier() *string {
	if t == nil {
		return nil
	}
	return t.ClientIdentifier
}

func (t *TranscodeSubtitlesRequest) GetProduct() *string {
	if t == nil {
		return nil
	}
	return t.Product
}

func (t *TranscodeSubtitlesRequest) GetVersion() *string {
	if t == nil {
		return nil
	}
	return t.Version
}

func (t *TranscodeSubtitlesRequest) GetPlatform() *string {
	if t == nil {
		return nil
	}
	return t.Platform
}

func (t *TranscodeSubtitlesRequest) GetPlatformVersion() *string {
	if t == nil {
		return nil
	}
	return t.PlatformVersion
}

func (t *TranscodeSubtitlesRequest) GetDevice() *string {
	if t == nil {
		return nil
	}
	return t.Device
}

func (t *TranscodeSubtitlesRequest) GetModel() *string {
	if t == nil {
		return nil
	}
	return t.Model
}

func (t *TranscodeSubtitlesRequest) GetDeviceVendor() *string {
	if t == nil {
		return nil
	}
	return t.DeviceVendor
}

func (t *TranscodeSubtitlesRequest) GetDeviceName() *string {
	if t == nil {
		return nil
	}
	return t.DeviceName
}

func (t *TranscodeSubtitlesRequest) GetMarketplace() *string {
	if t == nil {
		return nil
	}
	return t.Marketplace
}

func (t *TranscodeSubtitlesRequest) GetTranscodeType() components.TranscodeType {
	if t == nil {
		return components.TranscodeType("")
	}
	return t.TranscodeType
}

func (t *TranscodeSubtitlesRequest) GetTranscodeSessionID() *string {
	if t == nil {
		return nil
	}
	return t.TranscodeSessionID
}

func (t *TranscodeSubtitlesRequest) GetAdvancedSubtitles() *components.AdvancedSubtitles {
	if t == nil {
		return nil
	}
	return t.AdvancedSubtitles
}

func (t *TranscodeSubtitlesRequest) GetAudioBoost() *int64 {
	if t == nil {
		return nil
	}
	return t.AudioBoost
}

func (t *TranscodeSubtitlesRequest) GetAudioChannelCount() *int64 {
	if t == nil {
		return nil
	}
	return t.AudioChannelCount
}

func (t *TranscodeSubtitlesRequest) GetAutoAdjustQuality() *components.BoolInt {
	if t == nil {
		return nil
	}
	return t.AutoAdjustQuality
}

func (t *TranscodeSubtitlesRequest) GetAutoAdjustSubtitle() *components.BoolInt {
	if t == nil {
		return nil
	}
	return t.AutoAdjustSubtitle
}

func (t *TranscodeSubtitlesRequest) GetDirectPlay() *components.BoolInt {
	if t == nil {
		return nil
	}
	return t.DirectPlay
}

func (t *TranscodeSubtitlesRequest) GetDirectStream() *components.BoolInt {
	if t == nil {
		return nil
	}
	return t.DirectStream
}

func (t *TranscodeSubtitlesRequest) GetDirectStreamAudio() *components.BoolInt {
	if t == nil {
		return nil
	}
	return t.DirectStreamAudio
}

func (t *TranscodeSubtitlesRequest) GetDisableResolutionRotation() *components.BoolInt {
	if t == nil {
		return nil
	}
	return t.DisableResolutionRotation
}

func (t *TranscodeSubtitlesRequest) GetHasMDE() *components.BoolInt {
	if t == nil {
		return nil
	}
	return t.HasMDE
}

func (t *TranscodeSubtitlesRequest) GetLocation() *QueryParamLocation {
	if t == nil {
		return nil
	}
	return t.Location
}

func (t *TranscodeSubtitlesRequest) GetMediaBufferSize() *int64 {
	if t == nil {
		return nil
	}
	return t.MediaBufferSize
}

func (t *TranscodeSubtitlesRequest) GetMediaIndex() *int64 {
	if t == nil {
		return nil
	}
	return t.MediaIndex
}

func (t *TranscodeSubtitlesRequest) GetMusicBitrate() *int64 {
	if t == nil {
		return nil
	}
	return t.MusicBitrate
}

func (t *TranscodeSubtitlesRequest) GetOffset() *float64 {
	if t == nil {
		return nil
	}
	return t.Offset
}

func (t *TranscodeSubtitlesRequest) GetPartIndex() *int64 {
	if t == nil {
		return nil
	}
	return t.PartIndex
}

func (t *TranscodeSubtitlesRequest) GetPath() *string {
	if t == nil {
		return nil
	}
	return t.Path
}

func (t *TranscodeSubtitlesRequest) GetPeakBitrate() *int64 {
	if t == nil {
		return nil
	}
	return t.PeakBitrate
}

func (t *TranscodeSubtitlesRequest) GetPhotoResolution() *string {
	if t == nil {
		return nil
	}
	return t.PhotoResolution
}

func (t *TranscodeSubtitlesRequest) GetProtocol() *QueryParamProtocol {
	if t == nil {
		return nil
	}
	return t.Protocol
}

func (t *TranscodeSubtitlesRequest) GetSecondsPerSegment() *int64 {
	if t == nil {
		return nil
	}
	return t.SecondsPerSegment
}

func (t *TranscodeSubtitlesRequest) GetSubtitleSize() *int64 {
	if t == nil {
		return nil
	}
	return t.SubtitleSize
}

func (t *TranscodeSubtitlesRequest) GetSubtitles() *QueryParamSubtitles {
	if t == nil {
		return nil
	}
	return t.Subtitles
}

func (t *TranscodeSubtitlesRequest) GetVideoBitrate() *int64 {
	if t == nil {
		return nil
	}
	return t.VideoBitrate
}

func (t *TranscodeSubtitlesRequest) GetVideoQuality() *int64 {
	if t == nil {
		return nil
	}
	return t.VideoQuality
}

func (t *TranscodeSubtitlesRequest) GetVideoResolution() *string {
	if t == nil {
		return nil
	}
	return t.VideoResolution
}

func (t *TranscodeSubtitlesRequest) GetXPlexClientProfileExtra() *string {
	if t == nil {
		return nil
	}
	return t.XPlexClientProfileExtra
}

func (t *TranscodeSubtitlesRequest) GetXPlexClientProfileName() *string {
	if t == nil {
		return nil
	}
	return t.XPlexClientProfileName
}

func (t *TranscodeSubtitlesRequest) GetXPlexSessionIdentifier() *string {
	if t == nil {
		return nil
	}
	return t.XPlexSessionIdentifier
}

type TranscodeSubtitlesResponse struct {
	// HTTP response content type for this operation
	ContentType string
	// HTTP response status code for this operation
	StatusCode int
	// Raw HTTP response; suitable for custom response parsing
	RawResponse *http.Response
}

func (t *TranscodeSubtitlesResponse) GetContentType() string {
	if t == nil {
		return ""
	}
	return t.ContentType
}

func (t *TranscodeSubtitlesResponse) GetStatusCode() int {
	if t == nil {
		return 0
	}
	return t.StatusCode
}

func (t *TranscodeSubtitlesResponse) GetRawResponse() *http.Response {
	if t == nil {
		return nil
	}
	return t.RawResponse
}
