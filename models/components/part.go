// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"github.com/LukeHagar/plexgo/internal/utils"
)

// Part - `Part` represents a particular file or "part" of a media item. The part is the playable unit of the media hierarchy. Suppose that a movie library contains a movie that is broken up into files, reminiscent of a movie split across two BDs. The metadata item represents information about the movie, the media item represents this instance of the movie at this resolution and quality, and the part items represent the two playable files.  If another media were added which contained the joining of these two parts transcoded down to a lower resolution, then this metadata would contain 2 medias, one with 2 parts and one with 1 part.
type Part struct {
	// Indicates if the part is accessible.
	Accessible   *bool   `json:"accessible,omitempty"`
	AudioProfile *string `json:"audioProfile,omitempty"`
	// The container of the media file, such as `mp4` or `mkv`
	Container *string `json:"container,omitempty"`
	// The duration of the media item, in milliseconds
	Duration *int `json:"duration,omitempty"`
	// Indicates if the part exists.
	Exists *bool `json:"exists,omitempty"`
	// The local file path at which the part is stored on the server
	File            *string `json:"file,omitempty"`
	Has64bitOffsets *bool   `json:"has64bitOffsets,omitempty"`
	ID              int64   `json:"id"`
	Indexes         *string `json:"indexes,omitempty"`
	// The key from which the media can be streamed
	Key                   string `json:"key"`
	OptimizedForStreaming *bool  `json:"optimizedForStreaming,omitempty"`
	// The size of the media, in bytes
	Size                 *int64         `json:"size,omitempty"`
	Stream               []Stream       `json:"Stream,omitempty"`
	VideoProfile         *string        `json:"videoProfile,omitempty"`
	AdditionalProperties map[string]any `additionalProperties:"true" json:"-"`
}

func (p Part) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *Part) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"id", "key"}); err != nil {
		return err
	}
	return nil
}

func (p *Part) GetAccessible() *bool {
	if p == nil {
		return nil
	}
	return p.Accessible
}

func (p *Part) GetAudioProfile() *string {
	if p == nil {
		return nil
	}
	return p.AudioProfile
}

func (p *Part) GetContainer() *string {
	if p == nil {
		return nil
	}
	return p.Container
}

func (p *Part) GetDuration() *int {
	if p == nil {
		return nil
	}
	return p.Duration
}

func (p *Part) GetExists() *bool {
	if p == nil {
		return nil
	}
	return p.Exists
}

func (p *Part) GetFile() *string {
	if p == nil {
		return nil
	}
	return p.File
}

func (p *Part) GetHas64bitOffsets() *bool {
	if p == nil {
		return nil
	}
	return p.Has64bitOffsets
}

func (p *Part) GetID() int64 {
	if p == nil {
		return 0
	}
	return p.ID
}

func (p *Part) GetIndexes() *string {
	if p == nil {
		return nil
	}
	return p.Indexes
}

func (p *Part) GetKey() string {
	if p == nil {
		return ""
	}
	return p.Key
}

func (p *Part) GetOptimizedForStreaming() *bool {
	if p == nil {
		return nil
	}
	return p.OptimizedForStreaming
}

func (p *Part) GetSize() *int64 {
	if p == nil {
		return nil
	}
	return p.Size
}

func (p *Part) GetStream() []Stream {
	if p == nil {
		return nil
	}
	return p.Stream
}

func (p *Part) GetVideoProfile() *string {
	if p == nil {
		return nil
	}
	return p.VideoProfile
}

func (p *Part) GetAdditionalProperties() map[string]any {
	if p == nil {
		return nil
	}
	return p.AdditionalProperties
}
